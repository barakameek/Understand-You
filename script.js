Skip to main content
chat_spark
Create Prompt
mic
Stream Realtime
bolt
Starter Apps
tune
Tune a Model
home_storage
Library
chat_bubble
Persona Deck Builder: User Interface Design
chat_bubble
Persona Alchemy Lab Prototype Summary
chat_bubble
Kink Exploration Geometric Model
book_2
Prompt Gallery
quick_reference_all
API documentation
forum
Developer forum
view_agenda
Changelog NEW
This experimental model is for feedback and testing only. No production use.
settings
Settings
Persona Deck Builder: User Interface Design
drivecheck
John Adulcikas
Optional tone and style instructions for the model
Project: Persona Alchemy Lab (Now using "Deck Builder / Card Synergy" Metaphor)

Goal: Help users explore their sexual persona using 6 core elements (Attraction, Interaction, Sensory, Psychological, Cognitive, Relational) via an engaging, card-based interface.

Current Metaphor & State:

Metaphor: Shifted from "Alchemy Lab" to "Deck Builder / Card Synergy". Users discover "Concept Cards" and curate a "Persona Tapestry".

Core Data:

elementDetails: Holds detailed explanations and score interpretations for the 6 elements.

concepts: Array of ~45 concept objects, structured as "Cards" including id, name, cardType, visualHandle (placeholder), primaryElement (letter key), elementScores (letter keys), briefDescription, detailedDescription, relatedIds, rarity ('common'/'uncommon'/'rare'), and optional canUnlockArt/visualHandleUnlocked.

userScores: Stores final user element scores using single-letter keys (A, I, S, P, C, R).

discoveredConcepts: A Map storing discovered card data ({ concept, discoveredTime, artUnlocked }).

coreConcepts: A Set storing IDs of cards marked as "Core".

elementEssence & elementAttunement: Objects storing user progress using single-letter keys (A, I, S, P, C, R).

reflectionPrompts, dailyRituals, milestones: Data structures defined in data.js.

State tracking variables: seenPrompts, completedRituals, achievedMilestones, lastLoginDate (Persistence not yet implemented).

Screens & Functionality:

Setup: Standard "Guided Exploration" questionnaire calculates userScores.

Starter Hand: determineStarterHandAndEssence function is intended to run after setup to select ~7 resonant/varied cards, populate discoveredConcepts, and grant initial elementEssence/elementAttunement.

Study Screen (Main Hub): Displays elementEssence counters (clickable to trigger Research). Includes placeholders for dailyRituals. Research status is updated.

Research: conductResearch function triggered by spending Essence. Implements weighted random selection from undiscovered pool based on element affinity and elementAttunement, biased towards rarer cards at higher Attunement. Results shown in a modal.

Grimoire Screen: Displays discovered cards using renderCard function (shows rarity, art status via placeholder). Includes filters for Type, Element (using full names), Rarity, and Sort options.

Card Detail Pop-up: Shows full card info, dynamic Resonance analysis, recipe comparison, related concepts. Includes "Add to Grimoire" and "Mark as Core" buttons. Includes "Art Evolution" section (displayEvolutionSection) with button (attemptArtEvolution).

Persona Tapestry Screen: Displays detailed userScores interpretation, elementEssence, elementAttunement bars, coreConcepts (basic grid view), basic theme synthesis, and milestonesDisplay.

Essence: Generated by addToGrimoire, toggleCoreConcept (includes Synergy bonus check), handleConfirmReflection. Spent by conductResearch, attemptArtEvolution.

Attunement: Gained via gainAttunementForAction (triggered by various actions like discovery, core marking, reflection, research, evolution). Displayed on Persona screen.

Art Evolution: Logic implemented to unlock based on Core status, Reflection (simplified check), and Essence cost. Updates artUnlocked state in discoveredConcepts.

Reflection Prompts: Logic implemented (triggered by daily check placeholder & card additions), displays modal, grants Essence/Attunement on confirmation (simple checkbox). Tracks seenPrompts.

Rituals/Milestones: Basic display functions and tracking hooks (updateMilestoneProgress) implemented, but core logic for checking completion/granting complex rewards is placeholder. Milestone alert UI exists.

Navigation: Implemented between Study, Grimoire, Persona screens.

Code State: Provided full HTML, CSS, data.js, and script.js intended to implement all the above. Recent fixes addressed JSX comments, duplicate declarations, function order (ReferenceError), and key usage (euclideanDistance).

Current Known Issue:

Despite fixing previous syntax/reference errors, the application proceeds through the questionnaire but fails to populate the Starter Hand or Initial Essence.

The console logs indicate the determineStarterHandAndEssence function completes the initial state reset but does not log subsequent steps like "Concepts sorted..." or "Starter Hand Selected:", nor does it grant Essence. It appears to exit prematurely or fail silently after the initial state reset, likely during the concepts.map(...) or euclideanDistance calls within the loop, even though explicit errors from euclideanDistance are no longer showing. This results in empty Grimoire/Essence/Core displays.

The last attempted fix involved adding more detailed logging and a try...catch block within determineStarterHandAndEssence.

Next Objective: Debug the determineStarterHandAndEssence function using the detailed logs (from the last version provided) to understand why it's failing to select cards and grant essence, then proceed with testing and refining the implemented features.

Paste this message into the new chat, and I'll be ready to help debug the determineStarterHandAndEssence function based on the console output you get with the latest debugging code.

Thoughts
*The thoughts produced by the model are experimental
experiment

























































Expand to view model thoughts
Okay, I'm ready. Please paste the full script.js code (especially the determineStarterHandAndEssence function with its latest debugging logs) and the console output you are seeing when you run the application through the questionnaire.

Based on the description, I'll be looking specifically for:

The console logs that do appear from determineStarterHandAndEssence.

The last log message printed before the function seems to stop progressing.

Any potential silent failures indicated by missing subsequent logs (e.g., "Concepts sorted...", "Starter Hand Selected:").

The state of userScores and concepts just before the problematic section (if the logs capture it).

Let's dive into the debugging!

more kek informationg for you. here is the key inforation you need. Introduction:

The following 6 Core Elements form the fundamental attributes of an individual's sexual persona within this framework. Inspired by the idea of character attributes, these elements represent distinct dimensions along which sexuality can vary. Understanding your position on each spectrum helps illuminate the unique landscape of your desires, preferences, and identity. Your scores (typically 0-10) reflect your leaning within each element, derived from your self-assessment during the initial setup.

Attraction Focus

Core Question: Who or What sparks your sexual interest and arousal?

Core Concept: This element defines the primary target, nature, or necessary conditions for your sexual attraction. It goes beyond simple gender orientation to include the importance of presentation, specific dynamics, concepts, objects, situations, or the level of emotional connection required.

Elaboration: It encompasses traditional orientations (hetero-, homo-, bi-, pan-) but also acknowledges the Asexuality spectrum (lack of attraction) and Demisexuality (attraction requiring an emotional bond). It includes attractions focused on specific aesthetics, personality types, intellectual connection (Sapiosexuality), power dynamics, or even inanimate objects, materials, or scenarios (often termed fetishes or paraphilias, explored here non-judgmentally).

The Spectrum & Score Interpretation:

Very Low (0-2): Suggests very little or no specific sexual attraction (aligns strongly with the Asexuality spectrum). Arousal might be absent, rare, or triggered by non-specific stimuli.

Low (3-4): Indicates less emphasis on specific external targets; attraction might be infrequent, require strong emotional bonds first (Demisexual leaning), or be primarily responsive rather than spontaneous.

Moderate (5-6): Represents a common balance. Attraction might be geared towards familiar cues like gender or presentation, potentially broad (Pansexual leaning without intense focus), or require some connection without it being strictly Demisexual.

High (7-8): Suggests a strong focus or pull towards particular targets. This could be specific gender(s)/presentations, specific dynamics (like intelligence or power), or the beginning of significant focus on specific objects, materials, or situations (fetishistic interests).

Very High (9-10): Indicates a very strong, potentially primary, focus on specific triggers. This could be an intense orientation towards a narrow group, or a central role for specific objects, materials, scenarios, or conceptual dynamics in generating arousal (strong fetishistic or paraphilic focus).

Examples: Asexuality, Demisexuality, Heterosexuality, Homosexuality, Bisexuality, Pansexuality, Sapiosexuality, Fetishes (e.g., latex, feet, uniforms), attraction to specific body types, attraction based on D/s roles.

Persona Connection: Defines the fundamental "object" or condition of your sexual desire.

Interaction Style

Core Question: How do you prefer to engage and exchange energy during sexual encounters?

Core Concept: This element describes your preferred behavioral dynamics, roles, and energy flow when interacting sexually with others (or even in solo fantasy).

Elaboration: It covers the spectrum from leading to following, the desire for collaboration versus power differentials, and specific energetic expressions like nurturing, service, playfulness, or performance. It's strongly linked to identities like Dominant, Submissive, Switch, Top, Bottom, Caregiver, etc.

The Spectrum & Score Interpretation:

Very Low (0-2): Strong preference for yielding control, following explicit direction, serving, or being cared for/guided (Strongly Submissive leaning). Comfort in passivity or receiving.

Low (3-4): General comfort or preference for letting others take the lead, supportive roles, receiving attention/sensation more than directing it (Submissive or Bottom leaning).

Moderate (5-6): Prefers collaborative, egalitarian dynamics with mutual give-and-take. May enjoy switching roles (Switch identity) or find balance in playful, reciprocal exchanges.

High (7-8): Enjoys taking initiative, guiding the encounter, providing sensation/care, or being the center of attention (Dominant, Top, or Caregiver leaning).

Very High (9-10): Strong preference or need to be in control, direct the scenario explicitly, command, or embody a significantly Dominant role. May involve performance or intense focus on the other's response.

Examples: Dominance/submission (D/s), Master/slave (M/s), Top/Bottom/Versatile roles, Primal play (instinctive interaction), Service dynamics, Exhibitionism/Voyeurism (performance/observation roles), Teacher/student roles, Caregiver/Little dynamics (DDlg, MDlb).

Persona Connection: Defines your preferred social and power "dance" within sexuality.

Sensory Emphasis

Core Question: What physical Feelings are most important or sought after?

Core Concept: This element relates to the significance, type, and intensity of physical sensations in your sexual arousal and fulfillment.

Elaboration: It encompasses the full range of senses – touch (light, firm, impact), temperature (hot, cold), texture (smooth, rough), pressure (binding, squeezing), vibration, internal sensations, as well as visual, auditory, and olfactory input. It also includes the spectrum from pure pleasure to the integration of pain or intense sensation (Sadomasochism).

The Spectrum & Score Interpretation:

Very Low (0-2): Physical sensation is largely secondary or even unimportant compared to emotional connection, psychological needs, or cognitive engagement. Strong aversion to intense stimuli likely.

Low (3-4): Prefers subtle, gentle, affectionate, or "vanilla" physical sensations. Comfort, warmth, and light touch may be prioritized. Intense sensations are generally avoided.

Moderate (5-6): Enjoys a broad range of pleasurable physical sensations common in conventional sex. May be open to exploring mild intensity (e.g., light spanking, different textures) but it's not a primary driver.

High (7-8): Actively seeks out distinct, strong, or specific types of physical input as a key part of arousal. This could include impact play, temperature, specific textures (latex, rope), light restriction, or intense pleasure focus.

Very High (9-10): Strongly driven by, or requires, intense, specific, or even extreme physical sensations. This includes significant pain/pleasure play (heavy impact, needles, wax), intense restriction/bondage, sensory overload/deprivation, edge play, or a powerful focus on specific sensory triggers (e.g., specific materials against skin).

Examples: Gentle massage, passionate kissing, cuddling, BDSM impact play (flogging, caning), wax play, ice play, rope bondage, Shibari, sensory deprivation hoods, electrostimulation, specific material fetishes (focus on the feel).

Persona Connection: Defines how your body interfaces with sexuality and what physical input it craves or avoids.

Psychological Driver

Core Question: Why do you engage with sexuality? What underlying needs does it fulfill?

Core Concept: This element explores the core emotional, psychological, or existential motivations, needs, and states that sexuality helps you access, express, or satisfy.

Elaboration: This is about the deeper meaning or purpose behind the act. It includes needs for connection (intimacy, trust, vulnerability, belonging), power dynamics (control, dominance, surrender, objectification), self-expression (creativity, validation, exploration), state change (escape, transcendence, catharsis, stress relief), and comfort (security, care).

The Spectrum & Score Interpretation: (Score represents the overall importance of fulfilling any deep need via sexuality).

Very Low (0-2): Sexuality primarily serves physical functions or simple pleasure/recreation. Deep psychological needs are largely met elsewhere or aren't strongly linked to sex.

Low (3-4): Emotional or psychological aspects are present but secondary. Focus might be on fun, physical release, or light connection without significant depth or weight.

Moderate (5-6): A balanced approach where sexuality often fulfills needs like connection, stress relief, fun, and validation in fairly equal measure, integrated with physical pleasure.

High (7-8): Sexuality is a significant and important channel for fulfilling specific, core psychological needs. These needs (e.g., Intimacy, Power, Validation, Catharsis) are consciously or unconsciously sought through sexual expression.

Very High (9-10): Fulfilling one or more profound psychological needs is the primary driver and purpose of sexual engagement. The experience might feel incomplete or unsatisfying if these deep needs (e.g., total surrender, absolute control, deep vulnerability/trust, transcendental escape) are not met.

Examples: Using sex primarily for stress relief (Low/Moderate), seeking deep emotional intimacy through partnered sex (High), using BDSM for catharsis or power exchange (High/Very High), seeking validation through performance (High), using intense experiences for transcendence (Very High).

Persona Connection: Defines the emotional and motivational core of your sexual expression – its deeper purpose for you.

Cognitive Engagement

Core Question: How important is the Mind – fantasy, intellect, scenarios – in your arousal?

Core Concept: This element measures the degree and style of mental involvement preferred or required during sexual experiences. It contrasts focus on immediate physical/emotional presence with reliance on imagination, narrative, psychological complexity, or intellectual stimulation.

Elaboration: Includes everything from being fully "in the moment" to elaborate fantasy worlds, scripted role-plays, psychological games, intellectual banter, or focusing on the conceptual meaning of dynamics.

The Spectrum & Score Interpretation:

Very Low (0-2): Strong preference for being completely present and embodied. Finds elaborate fantasy, role-play, or complex psychological analysis distracting or uninteresting. Focus is purely on the physical and immediate emotional connection.

Low (3-4): Primarily enjoys the immediate experience. Mental constructs are minimal; perhaps light scenarios or appreciating a partner's mindset, but not reliant on internal narratives.

Moderate (5-6): Appreciates a degree of mental engagement. May enjoy occasional role-play, dirty talk that builds a picture, understanding the psychological dynamic, or using fantasy to enhance arousal, but can also enjoy purely present experiences.

High (7-8): Arousal is significantly enhanced or often triggered by mental elements. This includes enjoying detailed fantasies, specific role-playing scenarios, understanding and playing with psychological power dynamics, or engaging in witty/intellectual sexual banter.

Very High (9-10): Deeply reliant on the mind for arousal and fulfillment. This involves intricate, potentially pre-scripted scenarios, complex world-building in fantasy, intense psychological manipulation or analysis (mind games), or finding the conceptual/intellectual aspect paramount. The mental narrative is the core experience.

Examples: Mindful sensual touch (Low), enjoying descriptions during dirty talk (Moderate), elaborate D/s protocol scenes (High/Very High), historical or fantasy LARP-style sex (High/Very High), writing/reading erotica focused on complex plots (High/Very High), deep psychological edge play (Very High).

Persona Connection: Defines how much and in what way your thoughts, imagination, and intellect participate in your sexuality.

Relational Context

Core Question: In what Structure or with whom do you ideally express your sexuality?

Core Concept: This element describes your preferred social structure and context for sexual relationships and expression.

Elaboration: It considers the number of partners involved, the desired level of commitment and emotional intimacy, the importance of familiarity versus anonymity, and the preference for dyadic versus group interactions. It covers the spectrum from solitary practice through various forms of monogamy and consensual non-monogamy (CNM).

The Spectrum & Score Interpretation: (Score might represent leaning towards exclusivity vs. multiplicity/fluidity).

Very Low (0-2): Strong preference for solitary sexual expression or a deeply bonded, strictly exclusive lifelong partnership (Traditional Monogamy). Discomfort with or disinterest in multiple partners or casual encounters.

Low (3-4): Generally prefers and seeks monogamous, committed relationships as the ideal context for sexual expression. Casual sex is less appealing or infrequent.

Moderate (5-6): Comfortable with committed dyads but potentially open to some flexibility (e.g., swinging in specific contexts, dating casually before commitment) or values deep connection without strict long-term exclusivity. Might be exploring CNM or identify as Solo Poly.

High (7-8): Prefers or actively practices structures involving multiple partners or explicit openness, such as Open Relationships or common forms of Polyamory (hierarchical or not). Values communication around multiple connections.

Very High (9-10): Strong preference for highly fluid, non-traditional structures. May identify with Relationship Anarchy, practice non-hierarchical Polyamory with many partners, enjoy group dynamics, or be comfortable with varying levels of commitment and anonymity across different connections. Rejects rigid rules or default exclusivity.

Examples: Masturbation (Solitary), Serial Monogamy, Lifelong Monogamy, Friends With Benefits (Casual), Open Relationships, Swinging, Triads/Quads, Hierarchical Polyamory, Egalitarian Polyamory, Solo Polyamory, Relationship Anarchy, Group Sex, Anonymous Encounters.

Persona Connection: Defines the preferred social constellation or lack thereof for your sexual life.

Conclusion:

By understanding your leanings across these 6 detailed elements, you gain a multi-faceted view of your unique sexual persona. This foundation allows you to explore specific concepts and practices with a better understanding of why they might resonate, connecting the dots between your core attributes and the vast landscape of human sexuality.

Thoughts
*The thoughts produced by the model are experimental
experiment





















Expand to view model thoughts
Okay, thank you for providing this detailed breakdown of the 6 Core Elements. This is excellent context and clarifies the meaning behind the scores and element affinities within the project.

Here's how I see this information connecting to the project structure and the current debugging task:

elementDetails Data: This text is the rich source material that should populate (or has already populated) your elementDetails object in data.js. It provides the specific interpretations for different score ranges for each element (A, I, S, P, C, R).

userScores Interpretation: The scores calculated during the setup questionnaire and stored in userScores will be interpreted using the logic described here, likely on the "Persona Tapestry" screen.

concepts Relevance: The primaryElement and elementScores associated with each "Concept Card" in your concepts array directly relate to these descriptions. A card focused on "Dominance" would likely have a high score in 'I' (Interaction), while one focused on "Latex Feel" would score high in 'S' (Sensory).

determineStarterHandAndEssence Logic: The core task of this function is to find cards (concepts) that resonate with the user's profile (userScores). The resonance calculation (like the Euclidean distance you mentioned) compares the user's A, I, S, P, C, R scores against each card's A, I, S, P, C, R scores. These detailed descriptions help understand why a particular card should or shouldn't resonate based on the user's profile. For example, a user scoring high in 'C' (Cognitive) and low in 'S' (Sensory) should ideally be matched with starter cards reflecting fantasy, scenarios, or psychological play rather than intense physical sensation.

In short, this deep dive into the elements is crucial for understanding the intended behavior of the resonance calculation and card selection, even if it doesn't directly fix the code execution error. It helps us validate whether the function, once fixed, is actually selecting meaningful cards.

Now, I'm fully prepped with the conceptual background.

Please provide the script.js code (especially the determineStarterHandAndEssence function with the latest debugging logs) and the console output you see when running the app. Let's pinpoint why it's failing to populate the starter hand and grant essence.

file thumbnail
scrip.js
12,254 tokens
file thumbnail
style.css
10,830 tokens
file thumbnail
data.js
13,362 tokens
file thumbnail
index.html
2,532 tokens
here is the app

Thoughts
*The thoughts produced by the model are experimental
experiment




































































































Expand to view model thoughts
51.0s
Okay, I have the code (script.js, style.css, data.js, index.html) and the detailed element descriptions.

Based on your description of the problem:

The questionnaire completes.

finalizeScoresAndShowPersona is called.

determineStarterHandAndEssence is called.

The logs [determineStarterHand] Function called. and [determineStarterHand] State reset. appear.

No subsequent logs from within determineStarterHandAndEssence appear (specifically, not even the Processing ${concepts.length} total concepts. or the Dist calc for ID... logs, nor the final logs).

The Grimoire/Essence remain empty.

This strongly suggests the function is exiting very early, even before it starts processing the concepts array in the forEach loop, or fails on the very first attempt within that loop before hitting the logging statements.

Let's examine determineStarterHandAndEssence again with this specific stopping point in mind:

function determineStarterHandAndEssence() {
    console.log("[determineStarterHand] Function called."); // Log appears
    try {
        // Reset state
        discoveredConcepts = new Map();
        elementEssence = { A: 0, I: 0, S: 0, P: 0, C: 0, R: 0 };
        console.log("[determineStarterHand] State reset."); // Log appears

        let conceptsWithDistance = [];
        // *** Potential failure point 1: Accessing 'concepts.length' ***
        console.log(`[determineStarterHand] Processing ${concepts.length} total concepts.`); // Log DOES NOT appear

        // If the above log doesn't appear, the issue is accessing 'concepts' itself.
        // Is 'data.js' definitely loaded BEFORE 'script.js'? (Yes, checked index.html)
        // Is 'concepts' somehow overwritten or undefined before this function runs?

        // *** Potential failure point 2: The forEach loop structure or the first iteration ***
        concepts.forEach((c, index) => {
            // This code block is likely never entered, or fails immediately.
            console.log(`[determineStarterHand] Loop iteration ${index}`); // ADD THIS LOG

            const conceptScores = c.elementScores;
            if (!conceptScores || typeof conceptScores !== 'object') {
                 console.warn(`[determineStarterHand] Concept ID ${c.id} (${c.name}) missing/invalid elementScores. Skipping.`); // Log would appear if this was the issue
                 return; // This 'return' only exits the current iteration of forEach, not the function.
            }

            // Add log BEFORE calling the complex function
            console.log(`[determineStarterHand] PRE-DISTANCE CALL for ID ${c.id} (${c.name}) with userScores:`, userScores, `and conceptScores:`, conceptScores);

            const distance = euclideanDistance(userScores, conceptScores);

            // Add log AFTER calling the complex function
             console.log(`[determineStarterHand] POST-DISTANCE CALL for ID ${c.id}, distance: ${distance}`);

             // The original log was here, but we're not even getting this far
            // if (index < 15) { console.log(`[determineStarterHand] Dist calc for ID ${c.id} (${c.name}): ${distance}`); }

            if (distance !== Infinity && typeof distance === 'number' && !isNaN(distance)) {
                conceptsWithDistance.push({ ...c, distance: distance });
            } else {
                console.warn(`[determineStarterHand] Skipping concept ${c.id} (${c.name}) due to invalid distance: ${distance}`);
            }
        });

        // ... rest of the function (sorting, selection, granting essence) ...
        // None of the logs here appear either.

    } catch (error) {
        // If an error was thrown, this *should* log it.
        console.error("!!! ERROR in determineStarterHand !!!", error);
    }
    // This log also doesn't appear, suggesting the function exits prematurely OR the error isn't caught.
    console.log("[determineStarterHand] Function finished.");
}
Use code with caution.
JavaScript
Primary Suspects Based on Missing Logs:

concepts is not available/iterable: The most likely reason the Processing ${concepts.length} total concepts. log fails is that concepts is undefined or not an array when determineStarterHandAndEssence is called.

Check Script Order: index.html correctly lists data.js before script.js.

Check Variable Scope/Overwriting: Is there any code between data.js loading and this function call that might modify or delete the global concepts variable? (Unlikely in the provided code, but worth considering).

Check data.js Syntax: Is there a syntax error within data.js itself that prevents the concepts array from being correctly defined globally? Let's quickly scan data.js.

Looks okay syntactically. Object literals, commas, closing brackets/braces seem fine. The final elementKeyToFullName seems redundant as noted, but shouldn't break concepts.

Error Inside euclideanDistance on First Call: If the Processing... log did appear (and maybe you missed it or it scrolled away?), the next failure point is the very first call to euclideanDistance. An uncaught error inside that function could halt the forEach loop and potentially the entire script execution depending on the browser/environment, even with the outer try...catch.

Debugging Steps:

Verify concepts Availability: Add this log right at the beginning of determineStarterHandAndEssence, before the try block:

function determineStarterHandAndEssence() {
    console.log("[determineStarterHand] Function called.");
    // ADD THIS CHECK:
    console.log("[determineStarterHand] Checking 'concepts' variable type:", typeof concepts, "Is Array:", Array.isArray(concepts), "Length:", concepts?.length);
    // END ADDED CHECK

    try {
        // ... rest of the function
Use code with caution.
JavaScript
Run the app again. What does this log show?

If it shows undefined, object but not Array, or length 0/undefined, then the issue is with data.js loading or the concepts variable itself.

If it shows object, true, and a positive length (like 45), then concepts is likely fine, and the issue is later.

Add Logging Inside the Loop Start: If the above check shows concepts is okay, add the log suggested inside the loop to see if it even starts:

concepts.forEach((c, index) => {
    // ADD THIS LOG:
    console.log(`[determineStarterHand] Loop iteration ${index}, Concept ID: ${c?.id}`);
    // END ADDED LOG

    const conceptScores = c.elementScores;
    // ... rest of loop
Use code with caution.
JavaScript
Does the Loop iteration 0... log appear?

Add Pre/Post Logs Around euclideanDistance: If the loop iteration log does appear for index 0, add the logs before and after the euclideanDistance call as shown in the first code block above. This will tell us if the call itself is the problem, or if the distance calculation is returning something unexpected (Infinity is expected for bad data, but maybe it's throwing an error instead).

Let's start with Step 1. Please add the console.log to check the concepts variable right at the start of determineStarterHandAndEssence, run the questionnaire, and tell me what that log output says in the console.

70.1s
image.png
there is some thing wrong with the code. there is no error. but much of the functions of the app dont work. can you look at he code in detail and rewrite it do it works. script.js:446 DOM Fully Loaded. Initializing Card Concept Expanded...
script.js:449 Type of nextElement before attaching listener: function
script.js:156 Showing screen: welcomeScreen
script.js:471 Initial screen set to Welcome.
script.js:156 Showing screen: questionnaireScreen
script.js:242 Finalizing scores...
script.js:242 Final User Scores: {A: 5, I: 5, S: 5, P: 5, C: 5, …}
script.js:250 [determineStarterHand] Function called.
script.js:252 [determineStarterHand] State reset.
script.js:253 [determineStarterHand] Processing 44 total concepts.
script.js:256 [determineStarterHand] Dist calc for ID 1 (Vanilla Sex): 3.1622776601683795
script.js:256 [determineStarterHand] Dist calc for ID 2 (Sensual Touch): 3.605551275463989
script.js:256 [determineStarterHand] Dist calc for ID 3 (Passionate Kissing): 2.449489742783178
script.js:256 [determineStarterHand] Dist calc for ID 22 (Monogamy): 3.1622776601683795
script.js:256 [determineStarterHand] Dist calc for ID 23 (Serial Monogamy): 2
script.js:256 [determineStarterHand] Dist calc for ID 24 (Casual Sex / Hookups): 3.3166247903554
script.js:256 [determineStarterHand] Dist calc for ID 31 (Cuddling / Affection): 4.795831523312719
script.js:256 [determineStarterHand] Dist calc for ID 32 (Dirty Talk): 3
script.js:256 [determineStarterHand] Dist calc for ID 33 (Mutual Masturbation): 1.7320508075688772
script.js:256 [determineStarterHand] Dist calc for ID 4 (Dominance (Psychological)): 5.5677643628300215
script.js:256 [determineStarterHand] Dist calc for ID 5 (Submission (Psychological)): 5.196152422706632
script.js:256 [determineStarterHand] Dist calc for ID 6 (Switching): 2.8284271247461903
script.js:256 [determineStarterHand] Dist calc for ID 7 (Impact Play (Light)): 1.7320508075688772
script.js:256 [determineStarterHand] Dist calc for ID 13 (Role-Playing (Scenario)): 3.605551275463989
script.js:256 [determineStarterHand] Dist calc for ID 15 (Deep Emotional Intimacy): 5
script.js:259 [determineStarterHand] Found 44 concepts with valid distances.
script.js:261 [determineStarterHand] Concepts sorted (Top 15): (15) ['Mutual Masturbation(1.7)', 'Impact Play (Light)(1.7)', 'Serial Monogamy(2.0)', 'Passionate Kissing(2.4)', 'Open Relationship(2.4)', 'Swinging(2.6)', 'Switching(2.8)', 'Dirty Talk(3.0)', 'Vanilla Sex(3.2)', 'Monogamy(3.2)', 'Exhibitionism(3.2)', 'Casual Sex / Hookups(3.3)', 'Sensual Touch(3.6)', 'Role-Playing (Scenario)(3.6)', 'Uniform/Clothing Fetish(3.6)']
script.js:266 [determineStarterHand] Starter Hand Selected: (7) ['Mutual Masturbation', 'Impact Play (Light)', 'Serial Monogamy', 'Passionate Kissing', 'Dirty Talk', 'Uniform/Clothing Fetish', 'Open Relationship']
script.js:282 Attunement updated (discover): {A: 0, I: 0.5, S: 0, P: 0, C: 0, …}
script.js:282 Attunement updated (discover): {A: 0, I: 0.5, S: 0.5, P: 0, C: 0, …}
script.js:282 Attunement updated (discover): {A: 0, I: 0.5, S: 0.5, P: 0, C: 0, …}
script.js:282 Attunement updated (discover): {A: 0, I: 0.5, S: 1, P: 0, C: 0, …}
script.js:282 Attunement updated (discover): {A: 0, I: 0.5, S: 1, P: 0, C: 0.5, …}
script.js:282 Attunement updated (discover): {A: 0.5, I: 0.5, S: 1, P: 0, C: 0.5, …}
script.js:282 Attunement updated (discover): {A: 0.5, I: 0.5, S: 1, P: 0, C: 0.5, …}
script.js:269 [determineStarterHand] Initial Essence Granted: {A: 0, I: 0, S: 0, P: 0, C: 0, …}
script.js:271 [determineStarterHand] Function finished.
script.js:156 Showing screen: personaScreen
script.js:156 Showing screen: grimoireScreen
script.js:156 Showing screen: grimoireScreen
script.js:156 Showing screen: studyScreen
script.js:156 Showing screen: grimoireScreen
script.js:156 Showing screen: grimoireScreen
script.js:156 Showing screen: personaScreen
script.js:156 Showing screen: grimoireScreen
script.js:156 Showing screen: grimoireScreen
script.js:156 Showing screen: studyScreen
script.js:156 Showing screen: personaScreen
script.js:156 Showing screen: studyScreen
script.js:156 Showing screen: grimoireScreen
script.js:156 Showing screen: grimoireScreen
script.js:156 Showing screen: studyScreen
script.js:156 Showing screen: personaScreen
script.js:156 Showing screen: studyScreen
script.js:156 Showing screen: grimoireScreen
script.js:156 Showing screen: grimoireScreen
script.js:156 Showing screen: personaScreen

Thoughts
*The thoughts produced by the model are experimental
experiment






























































Expand to view model thoughts
35.9s
Okay, thank you for providing the code and the console logs.

The console logs are extremely helpful! They show that:

The questionnaire finishes, and userScores are calculated.

determineStarterHandAndEssence starts.

The concepts array is available and has 44 items.

The euclideanDistance function is working correctly and calculating distances for all concepts.

The sorting works.

A starter hand of 7 concepts is selected.

The loop to process the starter hand runs (as evidenced by the Attunement updated logs).

gainAttunementForAction seems to be working, updating the elementAttunement object.

Crucially: The log [determineStarterHand] Initial Essence Granted: {A: 0, I: 0, S: 0, P: 0, C: 0, R: 0} shows that even after the loop where grantEssenceForConcept should have been called 7 times, the elementEssence object is still completely empty.

The function finishes without crashing.

This confirms our suspicion: the problem lies specifically within the grantEssenceForConcept function or how it interacts with the elementEssence global variable. It's being called, but it's failing to actually add any essence.

Let's also address the other critical issue identified:

Missing elementKeyToFullName: Your data.js defines this map, but your script.js does not. Several functions rely on it (synthesizeAndDisplayThemesPersona, renderCard, conductResearch, potentially others indirectly). This will cause ReferenceErrors later.

Plan:

Fix elementKeyToFullName: Add the map definition back into script.js.

Debug grantEssenceForConcept: Add detailed logging inside this function to see exactly what's happening with the keys and calculations.

Debug discoveredConcepts: Add a log to confirm discoveredConcepts is being populated.

Review UI Update Calls: Ensure the functions to display essence/grimoire are called after the data should be ready.

Refactored script.js (incorporating fixes and debugging):

// script.js - FINAL COMPLETE VERSION v4 (Debugging Starter Hand/Essence + Key Fix)

// --- Global State ---
let currentElementIndex = 0;
let userScores = { A: 5, I: 5, S: 5, P: 5, C: 5, R: 5 }; // Use single letter keys
let userAnswers = {}; // Stores answers keyed by FULL element names during questionnaire
const elementNames = ["Attraction", "Interaction", "Sensory", "Psychological", "Cognitive", "Relational"]; // Full names for display/logic
const cardTypeKeys = ["Orientation", "Identity/Role", "Practice/Kink", "Psychological/Goal", "Relationship Style"]; // For filtering
let currentElementAnswers = {}; // Temp storage for current element's answers
let currentlyDisplayedConceptId = null;
let discoveredConcepts = new Map(); // ID -> { concept, discoveredTime, artUnlocked: boolean }
let coreConcepts = new Set(); // Track IDs marked as core
// *** Use single letter keys for consistency ***
let elementEssence = { A: 0, I: 0, S: 0, P: 0, C: 0, R: 0 };
let elementAttunement = { A: 0, I: 0, S: 0, P: 0, C: 0, R: 0 };
const MAX_ATTUNEMENT = 100;
const RESEARCH_COST = 5;
const ART_EVOLVE_COST = 5;

// --- Persistent State Tracking (Placeholder) ---
let seenPrompts = new Set();
let completedRituals = { daily: {}, weekly: {} };
let achievedMilestones = new Set();
let lastLoginDate = null;
let cardsAddedSinceLastPrompt = 0;
let promptCooldownActive = false;
let currentReflectionElement = null; // Store the FULL NAME of the element for reflection
let currentPromptId = null; // Store the ID of the prompt shown

// --- DOM Elements ---
// (Keep all DOM element const declarations as they were)
const screens = document.querySelectorAll('.screen');
const startButton = document.getElementById('startGuidedButton');
const questionnaireScreen = document.getElementById('questionnaireScreen');
const elementProgressHeader = document.getElementById('elementProgressHeader');
const questionContent = document.getElementById('questionContent');
const progressText = document.getElementById('progressText');
const dynamicScoreFeedback = document.getElementById('dynamicScoreFeedback');
const feedbackElementSpan = document.getElementById('feedbackElement');
const feedbackScoreSpan = document.getElementById('feedbackScore');
const feedbackScoreBar = document.getElementById('feedbackScoreBar');
const prevElementButton = document.getElementById('prevElementButton');
const nextElementButton = document.getElementById('nextElementButton');
const mainNavBar = document.getElementById('mainNavBar');
const navButtons = document.querySelectorAll('.nav-button');
const personaScreen = document.getElementById('personaScreen');
const personaElementDetailsDiv = document.getElementById('personaElementDetails');
const elementEssenceDisplayPersona = document.getElementById('elementEssenceDisplayPersona');
const personaCoreConceptsDisplay = document.getElementById('personaCoreConceptsDisplay');
const personaThemesList = document.getElementById('personaThemesList');
const restartButtonPersona = document.getElementById('restartButtonPersona');
const studyScreen = document.getElementById('studyScreen');
const elementEssenceDisplayStudy = document.getElementById('elementEssenceDisplayStudy');
const researchStatus = document.getElementById('researchStatus');
const grimoireScreen = document.getElementById('grimoireScreen');
const grimoireCountSpan = document.getElementById('grimoireCount');
const grimoireTypeFilter = document.getElementById('grimoireTypeFilter');
const grimoireElementFilter = document.getElementById('grimoireElementFilter');
const grimoireRarityFilter = document.getElementById('grimoireRarityFilter');
const grimoireSortOrder = document.getElementById('grimoireSortOrder');
const grimoireContentDiv = document.getElementById('grimoireContent');
const conceptDetailPopup = document.getElementById('conceptDetailPopup');
const popupOverlay = document.getElementById('popupOverlay');
const popupCardTypeIcon = document.getElementById('popupCardTypeIcon');
const popupConceptName = document.getElementById('popupConceptName');
const popupConceptType = document.getElementById('popupConceptType');
const popupCardVisual = document.getElementById('popupCardVisual');
const popupDetailedDescription = document.getElementById('popupDetailedDescription');
const popupResonanceSummary = document.getElementById('popupResonanceSummary');
const popupComparisonHighlights = document.getElementById('popupComparisonHighlights');
const popupConceptProfile = document.getElementById('popupConceptProfile');
const popupUserComparisonProfile = document.getElementById('popupUserComparisonProfile');
const popupRelatedConceptsList = document.getElementById('relatedConceptsList');
const closePopupButton = document.getElementById('closePopupButton');
const addToGrimoireButton = document.getElementById('addToGrimoireButton');
const markAsCoreButton = document.getElementById('markAsCoreButton');
const researchModal = document.getElementById('researchModal');
const researchModalContent = document.getElementById('researchModalContent');
const researchModalStatus = document.getElementById('researchModalStatus');
const closeResearchModalButton = document.getElementById('closeResearchModalButton');
const elementAttunementDisplay = document.getElementById('elementAttunementDisplay');
const dailyRitualsDisplay = document.getElementById('dailyRitualsDisplay');
const milestonesDisplay = document.getElementById('milestonesDisplay');
const popupEvolutionSection = document.getElementById('popupEvolutionSection');
const evolveArtButton = document.getElementById('evolveArtButton');
const evolveCostSpan = document.getElementById('evolveCost');
const evolveEligibility = document.getElementById('evolveEligibility');
const reflectionModal = document.getElementById('reflectionModal');
const closeReflectionModalButton = document.getElementById('closeReflectionModalButton');
const reflectionElement = document.getElementById('reflectionElement');
const reflectionPromptText = document.getElementById('reflectionPromptText');
const reflectionCheckbox = document.getElementById('reflectionCheckbox');
const confirmReflectionButton = document.getElementById('confirmReflectionButton');
const reflectionRewardAmount = document.getElementById('reflectionRewardAmount');
const milestoneAlert = document.getElementById('milestoneAlert');
const milestoneAlertText = document.getElementById('milestoneAlertText');
const closeMilestoneAlertButton = document.getElementById('closeMilestoneAlertButton');


// --- Utility & Setup Functions ---

function getScoreLabel(score) {
    if (typeof score !== 'number' || isNaN(score)) return "N/A";
    if (score >= 9) return "Very High";
    if (score >= 7) return "High";
    if (score >= 5) return "Moderate";
    if (score >= 3) return "Low";
    return "Very Low";
}

function getAffinityLevel(score) {
    if (typeof score !== 'number' || isNaN(score)) return null;
    if (score >= 8) return "High";
    if (score >= 5) return "Moderate";
    return null; // Return null for low affinity, simplifies checks
}

function getElementColor(elementName) { // Expects full name
    const colors = { Attraction: '#FF6347', Interaction: '#4682B4', Sensory: '#32CD32', Psychological: '#FFD700', Cognitive: '#8A2BE2', Relational: '#FF8C00' };
    return colors[elementName] || '#CCCCCC';
}

function hexToRgba(hex, alpha = 1) {
     if (!hex || typeof hex !== 'string') return `rgba(128,128,128, ${alpha})`;
     hex = hex.replace('#', ''); if (hex.length === 3) hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
     const bigint = parseInt(hex, 16); if (isNaN(bigint)) return `rgba(128,128,128, ${alpha})`;
     const r = (bigint >> 16) & 255; const g = (bigint >> 8) & 255; const b = bigint & 255;
     return `rgba(${r},${g},${b},${alpha})`;
}

function getCardTypeIcon(cardType) {
    switch (cardType) { case "Orientation": return "fa-solid fa-compass"; case "Identity/Role": return "fa-solid fa-mask"; case "Practice/Kink": return "fa-solid fa-gear"; case "Psychological/Goal": return "fa-solid fa-brain"; case "Relationship Style": return "fa-solid fa-heart"; default: return "fa-solid fa-question-circle"; }
}

function getElementIcon(elementName) { // Expects full name
     switch (elementName) { case "Attraction": return "fa-solid fa-magnet"; case "Interaction": return "fa-solid fa-users"; case "Sensory": return "fa-solid fa-hand-sparkles"; case "Psychological": return "fa-solid fa-comment-dots"; case "Cognitive": return "fa-solid fa-lightbulb"; case "Relational": return "fa-solid fa-link"; default: return "fa-solid fa-atom"; }
}

// --- Utility Maps ---
const elementNameToKey = { "Attraction": "A", "Interaction": "I", "Sensory": "S", "Psychological": "P", "Cognitive": "C", "Relational": "R" };
// *** FIX: Re-add elementKeyToFullName map ***
const elementKeyToFullName = { A: "Attraction", I: "Interaction", S: "Sensory", P: "Psychological", C: "Cognitive", R: "Relational" };


// *** Corrected euclideanDistance function (Keep as is) ***
function euclideanDistance(userScoresObj, conceptScoresObj) {
    let sumOfSquares = 0; let validDimensions = 0; let issueFound = false;
    if (!userScoresObj || typeof userScoresObj !== 'object') { console.error("Invalid user scores:", userScoresObj); return Infinity; }
    if (!conceptScoresObj || typeof conceptScoresObj !== 'object') { console.warn(`Invalid concept scores object for ID ${conceptScoresObj?.id || '?'}`); return Infinity; } // Added ID log
    const expectedKeys = Object.keys(userScoresObj); const expectedDimensions = expectedKeys.length;
    if (expectedDimensions === 0) { console.warn("User scores object is empty."); return Infinity; }

    for (const key of expectedKeys) {
        const s1 = userScoresObj[key]; const s2 = conceptScoresObj[key];
        const s1Valid = typeof s1 === 'number' && !isNaN(s1); const s2Valid = conceptScoresObj.hasOwnProperty(key) && typeof s2 === 'number' && !isNaN(s2);

        if (s1Valid && s2Valid) {
            sumOfSquares += Math.pow(s1 - s2, 2); validDimensions++;
        } else {
            // Only log if the concept score is the problem, assume user score is valid at this point
            if (!s2Valid) { console.warn(`Invalid/Missing CONCEPT score for key ${key}. Concept ID: ${conceptScoresObj.id || '?'}`); }
            issueFound = true; // Mark issue if any dimension fails
            // No need to return Infinity immediately, let's check all dimensions first
        }
    }
    // Check for issues after the loop
    if (validDimensions !== expectedDimensions) {
        console.warn(`Dimension mismatch or invalid data. Expected ${expectedDimensions}, got ${validDimensions} valid. Concept ID: ${conceptScoresObj.id || '?'}`, userScoresObj, conceptScoresObj);
        issueFound = true;
    }

    return !issueFound ? Math.sqrt(sumOfSquares) : Infinity;
}


// --- Screen Management ---
function showScreen(screenId) {
    console.log("Showing screen:", screenId);
    let targetIsMain = ['personaScreen', 'studyScreen', 'grimoireScreen'].includes(screenId);
    screens.forEach(screen => { screen.classList.toggle('current', screen.id === screenId); screen.classList.toggle('hidden', screen.id !== screenId); });
    if (mainNavBar) mainNavBar.classList.toggle('hidden', !targetIsMain); else console.warn("mainNavBar not found");
    navButtons.forEach(button => { button.classList.toggle('active', button.dataset.target === screenId); });
    if (['questionnaireScreen', 'grimoireScreen', 'personaScreen', 'studyScreen'].includes(screenId)) { window.scrollTo(0, 0); }
}

function hidePopups() {
    if (conceptDetailPopup) conceptDetailPopup.classList.add('hidden');
    if (researchModal) researchModal.classList.add('hidden');
    if (reflectionModal) reflectionModal.classList.add('hidden');
    if (popupOverlay) popupOverlay.classList.add('hidden');
    currentlyDisplayedConceptId = null; currentReflectionElement = null; currentPromptId = null;
}

// --- Initialization and Questionnaire Logic ---
function initializeQuestionnaire() {
    currentElementIndex = 0; userScores = { A: 5, I: 5, S: 5, P: 5, C: 5, R: 5 }; userAnswers = {}; elementNames.forEach(elName => { userAnswers[elName] = {}; });
    discoveredConcepts = new Map(); coreConcepts = new Set(); elementEssence = { A: 0, I: 0, S: 0, P: 0, C: 0, R: 0 }; elementAttunement = { A: 0, I: 0, S: 0, P: 0, C: 0, R: 0 };
    seenPrompts = new Set(); completedRituals = { daily: {}, weekly: {} }; achievedMilestones = new Set(); lastLoginDate = null; cardsAddedSinceLastPrompt = 0; promptCooldownActive = false;
    updateElementProgressHeader(-1); displayElementQuestions(currentElementIndex); showScreen('questionnaireScreen'); if (mainNavBar) mainNavBar.classList.add('hidden');
    // Clear displays explicitly
    if(dailyRitualsDisplay) dailyRitualsDisplay.innerHTML = '<li>Loading...</li>';
    if(milestonesDisplay) milestonesDisplay.innerHTML = '<li>None yet</li>';
    if(elementAttunementDisplay) elementAttunementDisplay.innerHTML = '';
    if(grimoireContentDiv) grimoireContentDiv.innerHTML = '<p style="text-align: center; color: #666;">Grimoire empty.</p>';
    if(personaCoreConceptsDisplay) personaCoreConceptsDisplay.innerHTML = '<li>Mark concepts as "Core" to build your tapestry.</li>';
    if(elementEssenceDisplayPersona) elementEssenceDisplayPersona.innerHTML = '<p style="font-size: 0.85em; text-align: left; color: #777;"><i>No Essence.</i></p>';
    if(elementEssenceDisplayStudy) elementEssenceDisplayStudy.innerHTML = ''; // Will be populated later
    updateGrimoireCounter(); // Should show 0
}

// --- Questionnaire Display/Logic Functions (Keep as is) ---
function updateElementProgressHeader(activeIndex) { /* ... no changes needed ... */
    if (!elementProgressHeader) return; elementProgressHeader.innerHTML = '';
    elementNames.forEach((name, index) => { const tab = document.createElement('div'); tab.classList.add('element-tab'); const elementData = elementDetails[name] || {}; tab.textContent = (elementData.name || name).substring(0, 3).toUpperCase(); tab.title = elementData.name || name; tab.classList.toggle('completed', index < activeIndex); tab.classList.toggle('active', index === activeIndex); elementProgressHeader.appendChild(tab); });
}
function displayElementQuestions(index) { /* ... no changes needed ... */
    if (index >= elementNames.length) { finalizeScoresAndShowPersona(); return; }
    const elementName = elementNames[index]; const elementData = elementDetails[elementName] || {}; const questions = questionnaireGuided[elementName] || [];
    const questionContentElement = document.getElementById('questionContent'); if (!questionContentElement) { console.error("!!! questionContent element not found !!!"); return; }
    let introHTML = `<div class="element-intro"><h2>${elementData.name || elementName}</h2><p><em>${elementData.coreQuestion || ''}</em></p><p>${elementData.coreConcept || 'Loading...'}</p><p><small><strong>Persona Connection:</strong> ${elementData.personaConnection || ''}</small></p></div>`; questionContentElement.innerHTML = introHTML;
    currentElementAnswers = { ...(userAnswers[elementName] || {}) }; let questionsHTML = '';
    if (questions && questions.length > 0) {
        questions.forEach(q => {
            let inputHTML = `<div class="question-block" id="block_${q.qId}"><h3 class="question-title">${q.text}</h3><div class="input-container">`; const savedAnswer = currentElementAnswers[q.qId];
            if (q.type === "slider") { const val = savedAnswer !== undefined ? savedAnswer : q.defaultValue; inputHTML += `<div class="slider-container"><input type="range" id="${q.qId}" class="slider q-input" min="${q.minValue}" max="${q.maxValue}" step="${q.step || 0.5}" value="${val}" data-question-id="${q.qId}" data-type="slider"><div class="label-container"><span class="label-text">${q.minLabel}</span><span class="label-text">${q.maxLabel}</span></div><p class="value-text">Selected: <span id="display_${q.qId}">${parseFloat(val).toFixed(1)}</span></p></div>`; }
            else if (q.type === "radio") { inputHTML += `<div class="radio-options">`; q.options.forEach(opt => { const checked = savedAnswer === opt.value ? 'checked' : ''; inputHTML += `<div><input type="radio" id="${q.qId}_${opt.value}" class="q-input" name="${q.qId}" value="${opt.value}" ${checked} data-question-id="${q.qId}" data-type="radio"><label for="${q.qId}_${opt.value}">${opt.value}</label></div>`; }); inputHTML += `</div>`; }
            else if (q.type === "checkbox") { inputHTML += `<div class="checkbox-options">`; q.options.forEach(opt => { const checked = savedAnswer?.includes(opt.value) ? 'checked' : ''; inputHTML += `<div><input type="checkbox" id="${q.qId}_${opt.value}" class="q-input" name="${q.qId}" value="${opt.value}" ${checked} data-question-id="${q.qId}" data-max-choices="${q.maxChoices || 2}" data-type="checkbox"><label for="${q.qId}_${opt.value}">${opt.value}</label></div>`; }); inputHTML += `</div>`; }
            inputHTML += `</div></div>`; questionsHTML += inputHTML;
        });
    } else { console.warn(`[displayElementQuestions] No questions found for element: ${elementName}`); questionsHTML = '<p><em>(No questions defined)</em></p>'; }
    const introDiv = questionContentElement.querySelector('.element-intro'); if (introDiv) { introDiv.insertAdjacentHTML('afterend', questionsHTML); } else { questionContentElement.innerHTML += questionsHTML; }
    questionContentElement.querySelectorAll('.q-input').forEach(input => { const eventType = (input.type === 'range') ? 'input' : 'change'; input.addEventListener(eventType, handleQuestionnaireInputChange); });
    questionContentElement.querySelectorAll('input[type="checkbox"].q-input').forEach(checkbox => { checkbox.addEventListener('change', (event) => enforceMaxChoices(checkbox.name, parseInt(checkbox.dataset.maxChoices || 2), event)); });
    updateElementProgressHeader(index); if (progressText) progressText.textContent = `Element ${index + 1} / ${elementNames.length}: ${elementData.name || elementName}`; updateDynamicFeedback(elementName); if (dynamicScoreFeedback) dynamicScoreFeedback.style.display = 'block'; if (prevElementButton) prevElementButton.style.visibility = (index > 0) ? 'visible' : 'hidden'; if (nextElementButton) nextElementButton.textContent = (index === elementNames.length - 1) ? "View My Persona" : "Next Element";
}
function handleQuestionnaireInputChange(event) { /* ... no changes needed ... */
    const input = event.target; const type = input.dataset.type; const elementName = elementNames[currentElementIndex];
    if (type === 'slider') { const qId = input.dataset.questionId; const display = document.getElementById(`display_${qId}`); if (display) display.textContent = parseFloat(input.value).toFixed(1); }
    collectCurrentElementAnswers(); updateDynamicFeedback(elementName);
}
function enforceMaxChoices(name, max, event) { /* ... no changes needed ... */
     const checkboxes = questionContent?.querySelectorAll(`input[name="${name}"]:checked`); if (!checkboxes) return;
     if (checkboxes.length > max) { alert(`Max ${max} options.`); if (event?.target?.checked) { event.target.checked = false; collectCurrentElementAnswers(); updateDynamicFeedback(elementNames[currentElementIndex]); } }
}
function collectCurrentElementAnswers() { /* ... no changes needed ... */
    const elementName = elementNames[currentElementIndex]; const questions = questionnaireGuided[elementName] || []; currentElementAnswers = {};
    questions.forEach(q => { const qId = q.qId; const container = questionContent || document; if (q.type === 'slider') { const input = container.querySelector(`#${qId}.q-input`); if (input) currentElementAnswers[qId] = parseFloat(input.value); } else if (q.type === 'radio') { const checked = container.querySelector(`input[name="${qId}"]:checked`); if (checked) currentElementAnswers[qId] = checked.value; } else if (q.type === 'checkbox') { const checked = container.querySelectorAll(`input[name="${qId}"]:checked`); currentElementAnswers[qId] = Array.from(checked).map(cb => cb.value); } });
    userAnswers[elementName] = { ...currentElementAnswers };
}
function updateDynamicFeedback(elementName) { /* ... no changes needed ... */
    if (!dynamicScoreFeedback || !feedbackElementSpan || !feedbackScoreSpan || !feedbackScoreBar) return; const tempScore = calculateElementScore(elementName, currentElementAnswers); feedbackElementSpan.textContent = elementDetails[elementName]?.name || elementName; feedbackScoreSpan.textContent = tempScore.toFixed(1); let labelSpan = dynamicScoreFeedback.querySelector('.score-label'); if (!labelSpan) { labelSpan = document.createElement('span'); labelSpan.classList.add('score-label'); feedbackScoreSpan.parentNode.insertBefore(document.createTextNode(' '), feedbackScoreSpan.nextSibling); feedbackScoreSpan.parentNode.insertBefore(labelSpan, feedbackScoreSpan.nextSibling.nextSibling); } labelSpan.textContent = `(${getScoreLabel(tempScore)})`; feedbackScoreBar.style.width = `${tempScore * 10}%`;
}
function calculateElementScore(elementName, answersForElement) { /* ... no changes needed ... */
    const questions = questionnaireGuided[elementName] || []; let score = 5.0;
    questions.forEach(q => { const answer = answersForElement[q.qId]; let pointsToAdd = 0; if (q.type === 'slider') { const value = (answer !== undefined) ? answer : q.defaultValue; pointsToAdd = (value - q.defaultValue) * (q.scoreWeight || 1.0); } else if (q.type === 'radio') { const opt = q.options.find(o => o.value === answer); pointsToAdd = opt ? (opt.points || 0) * (q.scoreWeight || 1.0) : 0; } else if (q.type === 'checkbox' && Array.isArray(answer)) { answer.forEach(val => { const opt = q.options.find(o => o.value === val); pointsToAdd += opt ? (opt.points || 0) * (q.scoreWeight || 1.0) : 0; }); } score += pointsToAdd; });
    return Math.max(0, Math.min(10, score));
}
function nextElement() { /* ... no changes needed ... */
    collectCurrentElementAnswers(); currentElementIndex++; displayElementQuestions(currentElementIndex);
}
function prevElement() { /* ... no changes needed ... */
     collectCurrentElementAnswers(); currentElementIndex--; displayElementQuestions(currentElementIndex);
}


function finalizeScoresAndShowPersona() {
     console.log("Finalizing scores..."); const finalScores = {}; elementNames.forEach(elementName => { const score = calculateElementScore(elementName, userAnswers[elementName] || {}); const key = elementNameToKey[elementName]; if (key) { finalScores[key] = score; } }); userScores = finalScores; console.log("Final User Scores:", userScores);

     // Run starter hand selection
     determineStarterHandAndEssence();

     // Update Milestones *after* starter hand potentially adds concepts
     updateMilestoneProgress('completeQuestionnaire', 1);

     // Update UI elements *AFTER* data should be populated
     displayPersonaScreen(); // Includes essence, attunement, core concepts
     displayElementEssenceStudy(); // Update study screen essence
     displayDailyRituals(); // Update rituals (if dependent on state)
     displayMilestones(); // Update milestone display
     populateGrimoireFilters(); // Populate filter dropdowns
     updateGrimoireCounter(); // Update count based on discoveredConcepts
     displayGrimoire(); // Try displaying the grimoire initially

     checkForDailyLogin(); // Check login status

     // Show the main screen
     showScreen('personaScreen'); // Start on persona screen
     setTimeout(() => { alert("Experiment Complete! Explore your Persona Tapestry, Grimoire, and The Study."); }, 100);
}

// --- Starter Hand & Initial Essence ---
function determineStarterHandAndEssence() {
    console.log("[determineStarterHand] Function called.");
     // Verify concepts availability
    console.log("[determineStarterHand] Checking 'concepts' variable type:", typeof concepts, "Is Array:", Array.isArray(concepts), "Length:", concepts?.length);

    try {
        // Reset state (already done in initialize, but safe to repeat)
        discoveredConcepts = new Map();
        elementEssence = { A: 0, I: 0, S: 0, P: 0, C: 0, R: 0 };
        console.log("[determineStarterHand] State reset.");

        if (!concepts || !Array.isArray(concepts) || concepts.length === 0) {
             console.error("[determineStarterHand] 'concepts' array is missing or empty!");
             return; // Cannot proceed
        }

        let conceptsWithDistance = [];
        console.log(`[determineStarterHand] Processing ${concepts.length} total concepts.`);

        concepts.forEach((c, index) => {
            // Basic check for concept structure
            if (!c || typeof c !== 'object' || !c.id || !c.elementScores) {
                console.warn(`[determineStarterHand] Skipping invalid concept at index ${index}:`, c);
                return; // Skip this iteration
            }

            const conceptScores = c.elementScores;
            // Note: euclideanDistance now logs warnings internally for bad concept scores
            const distance = euclideanDistance(userScores, conceptScores);

            // Log first few calculations for verification
            if (index < 5) {
                 console.log(`[determineStarterHand] Dist calc for ID ${c.id} (${c.name}): ${distance}`);
            }

            if (distance !== Infinity && typeof distance === 'number' && !isNaN(distance)) {
                conceptsWithDistance.push({ ...c, distance: distance });
            } else {
                 // Warning should already be logged by euclideanDistance if conceptScores were bad
                 // Log if distance calc failed for other reasons (e.g., userScores issue)
                 if (distance === Infinity) {
                     console.warn(`[determineStarterHand] Skipping concept ${c.id} (${c.name}) due to Infinity distance (check userScores or conceptScores structure).`);
                 } else {
                    console.warn(`[determineStarterHand] Skipping concept ${c.id} (${c.name}) due to invalid distance result: ${distance}`);
                 }
            }
        });

        console.log(`[determineStarterHand] Found ${conceptsWithDistance.length} concepts with valid distances.`);
        if (conceptsWithDistance.length === 0) {
            console.error("[determineStarterHand] No concepts comparable! Cannot select starter hand.");
            return; // Cannot proceed
        }

        // Sort by distance
        conceptsWithDistance.sort((a, b) => a.distance - b.distance);
        console.log("[determineStarterHand] Concepts sorted (Top 15):", conceptsWithDistance.slice(0,15).map(c => `${c.name}(${c.distance.toFixed(1)})`));

        // Selection Logic (keep as is, seems reasonable)
        const candidates = conceptsWithDistance.slice(0, 15); // Consider top 15 closest
        const starterHand = [];
        const representedElements = new Set();
        const starterHandIds = new Set();

        // 1. Prioritize closest matches (up to 4)
        for (const c of candidates) {
            if (starterHand.length >= 4) break;
            if (!starterHandIds.has(c.id)) { // Avoid duplicates
                starterHand.push(c);
                starterHandIds.add(c.id);
                if (c.primaryElement) representedElements.add(c.primaryElement);
            }
        }

        // 2. Add variety (up to 7 total) - prioritize unrepresented primary elements
        for (const c of candidates) {
             if (starterHand.length >= 7) break;
             if (starterHandIds.has(c.id)) continue; // Skip already added

             const isRepresented = c.primaryElement && representedElements.has(c.primaryElement);
             // Check if all remaining candidates have represented primary elements OR we still need cards
             const forceAdd = candidates.slice(candidates.indexOf(c)).every(remaining =>
                 (remaining.primaryElement && representedElements.has(remaining.primaryElement)) || starterHand.length >= 7
             );

             if (!isRepresented || forceAdd) {
                 starterHand.push(c);
                 starterHandIds.add(c.id);
                 if (c.primaryElement) representedElements.add(c.primaryElement);
             }
        }

         // 3. Fill remaining slots if needed (up to 7) from closest
        for (const c of candidates) {
            if (starterHand.length >= 7) break;
            if (!starterHandIds.has(c.id)) {
                starterHand.push(c);
                starterHandIds.add(c.id);
                // Don't need to track representedElements here anymore
            }
        }


        console.log("[determineStarterHand] Starter Hand Selected:", starterHand.map(c => c.name));
        if (starterHand.length === 0) {
            console.error("[determineStarterHand] Failed to select any starter hand cards!");
            return; // Cannot proceed
        }

        // Process selected starter hand: Add to discovered, grant essence, grant attunement
        starterHand.forEach(concept => {
            console.log(`[determineStarterHand] Processing starter card: ${concept.name} (ID: ${concept.id})`);
            // Add to discovered concepts
            discoveredConcepts.set(concept.id, { concept: concept, discoveredTime: Date.now(), artUnlocked: false });
            // Grant initial essence (multiplier 0.5)
            grantEssenceForConcept(concept, 0.5); // DEBUG THIS FUNCTION CALL
            // Grant initial attunement
            gainAttunementForAction('discover', concept.primaryElement);
        });

        // *** DEBUG LOG: Check discovered concepts map ***
        console.log("[determineStarterHand] Discovered Concepts Map after loop:", discoveredConcepts);
        console.log(`[determineStarterHand] Discovered Concepts Count: ${discoveredConcepts.size}`);

        // *** DEBUG LOG: Check final essence state ***
        console.log("[determineStarterHand] Final Initial Essence State:", elementEssence); // Check if non-zero now


    } catch (error) {
        console.error("!!! UNCAUGHT ERROR in determineStarterHand !!!", error); // More specific error log
    }
    console.log("[determineStarterHand] Function finished.");
}


// --- Attunement ---
function gainAttunementForAction(actionType, elementKey = null, amount = 0.5) {
    let targetKeys = [];
    const gainAmount = amount; // Use fixed amount passed

    if (elementKey && elementAttunement.hasOwnProperty(elementKey)) {
        targetKeys.push(elementKey);
    } else if (actionType === 'completeReflection' && currentReflectionElement) {
        // Get key from the stored full name
        const key = elementNameToKey[currentReflectionElement];
        if (key && elementAttunement.hasOwnProperty(key)) {
            targetKeys.push(key);
        } else {
             console.warn(`Could not find key for reflection element: ${currentReflectionElement}`);
        }
    } else if (actionType === 'generic' || elementKey === 'All') {
        targetKeys = Object.keys(elementAttunement);
        amount = 0.1; // Override amount for 'All'
    } else {
        // console.warn(`gainAttunement: Invalid elementKey (${elementKey}) or actionType (${actionType}) without key.`);
        return; // No valid target key found
    }

    let changed = false;
    targetKeys.forEach(key => {
        const currentAttunement = elementAttunement[key] || 0;
        const newAttunement = Math.min(MAX_ATTUNEMENT, currentAttunement + gainAmount);
        if (newAttunement > currentAttunement) {
            elementAttunement[key] = newAttunement;
            changed = true;
        }
    });

    if (changed) {
        console.log(`Attunement updated (${actionType}, Key: ${elementKey || 'Multi/None'}):`, elementAttunement);
        displayElementAttunement(); // Update UI if changed
    }
}

function displayElementAttunement() { /* ... no changes needed ... */
    if (!elementAttunementDisplay) return; elementAttunementDisplay.innerHTML = '';
    elementNames.forEach(elName => {
        const key = elementNameToKey[elName]; const attunementValue = elementAttunement[key] || 0; const percentage = (attunementValue / MAX_ATTUNEMENT) * 100;
        elementAttunementDisplay.innerHTML += `<div class="attunement-item"><span class="attunement-name">${elementDetails[elName]?.name || elName}:</span><div class="attunement-bar-container" title="${attunementValue.toFixed(1)} / ${MAX_ATTUNEMENT}"><div class="attunement-bar" style="width: ${percentage}%; background-color: ${getElementColor(elName)};"></div></div></div>`;
    });
}

// --- Persona Screen Functions ---
function displayPersonaScreen() { /* ... no changes needed ... */
    if (!personaElementDetailsDiv) { console.error("Persona details div not found!"); return; } personaElementDetailsDiv.innerHTML = '';
    elementNames.forEach(elementName => {
        const key = elementNameToKey[elementName]; const score = userScores[key]; const scoreLabel = getScoreLabel(score); const elementData = elementDetails[elementName] || {}; const interpretation = elementData.scoreInterpretations?.[scoreLabel] || "N/A"; const barWidth = score ? (score / 10) * 100 : 0; // Handle potential undefined score
        const details = document.createElement('details'); details.classList.add('element-detail-entry');
        details.innerHTML = `<summary class="element-detail-header"><div><strong>${elementData.name || elementName}:</strong><span>${score?.toFixed(1) ?? '?'}</span> <span class="score-label">(${scoreLabel})</span></div><div class="score-bar-container"><div style="width: ${barWidth}%; background-color: ${getElementColor(elementName)};"></div></div></summary><div class="element-description"><p><strong>Core Concept:</strong> ${elementData.coreConcept || ''}</p><p><strong>Elaboration:</strong> ${elementData.elaboration || ''}</p><hr><p><strong>Your Score (${scoreLabel}):</strong> ${interpretation}</p><p><small><strong>Examples:</strong> ${elementData.examples || ''}</small></p></div>`;
        personaElementDetailsDiv.appendChild(details);
    });
    displayElementEssencePersona(); displayElementAttunement(); displayCoreConceptsPersona(); synthesizeAndDisplayThemesPersona(); displayMilestones();
}
function displayElementEssencePersona() { /* ... no changes needed ... */
    if (!elementEssenceDisplayPersona) return; elementEssenceDisplayPersona.innerHTML = ''; let hasEssence = false;
    elementNames.forEach(elName => {
        const key = elementNameToKey[elName]; const essenceValue = parseFloat(elementEssence[key] || 0); if (essenceValue > 0.001) hasEssence = true; // Use small threshold
        elementEssenceDisplayPersona.innerHTML += `<div class="essence-item"><span class="essence-icon" style="background-color: ${getElementColor(elName)};"></span><span class="essence-name">${elementDetails[elName]?.name || elName}:</span><span class="essence-value">${essenceValue.toFixed(1)}</span></div>`;
    });
    if (!hasEssence) { elementEssenceDisplayPersona.innerHTML += '<p style="font-size: 0.85em; text-align: left; color: #777;"><i>No Essence. Discover or reflect to gain some.</i></p>'; }
}
function displayCoreConceptsPersona() { /* ... no changes needed ... */
    if (!personaCoreConceptsDisplay) return; personaCoreConceptsDisplay.innerHTML = '';
    if (coreConcepts.size === 0) { personaCoreConceptsDisplay.innerHTML = '<li>Mark concepts as "Core" from the Grimoire or detail view to build your tapestry.</li>'; return; }
    coreConcepts.forEach(conceptId => { const conceptData = discoveredConcepts.get(conceptId); if (conceptData?.concept) { const concept = conceptData.concept; const item = document.createElement('div'); item.classList.add('core-concept-item'); item.dataset.conceptId = concept.id; item.title = `View ${concept.name}`; item.innerHTML = `<i class="${getCardTypeIcon(concept.cardType)}"></i><span class="name">${concept.name}</span><span class="type">(${concept.cardType})</span>`; item.addEventListener('click', () => showConceptDetailPopup(concept.id)); personaCoreConceptsDisplay.appendChild(item); } else { console.warn(`Core concept ID ${conceptId} not found in discoveredConcepts.`); } });
}
// *** FIX: Use elementKeyToFullName map ***
function synthesizeAndDisplayThemesPersona() {
     if (!personaThemesList) return; personaThemesList.innerHTML = '';
     if (coreConcepts.size === 0) { personaThemesList.innerHTML = '<li>Mark Core Concepts for themes.</li>'; return; }
     const elementCountsByKey = { A: 0, I: 0, S: 0, P: 0, C: 0, R: 0 }; const threshold = 7.0;
     coreConcepts.forEach(id => {
         const discoveredData = discoveredConcepts.get(id); // Get from discovered map
         const concept = discoveredData?.concept; // Extract concept
         if (concept?.elementScores) {
             for (const key in concept.elementScores) {
                 // Use hasOwnProperty on the key map for safety
                 if (elementKeyToFullName.hasOwnProperty(key) && concept.elementScores[key] >= threshold) {
                    elementCountsByKey[key]++;
                 }
             }
         }
     });
     // Use elementKeyToFullName here
     const sortedThemes = Object.entries(elementCountsByKey)
         .filter(([key, count]) => count > 0 && elementKeyToFullName[key]) // Ensure key exists in map
         .sort(([, a], [, b]) => b - a)
         .map(([key, count]) => ({ name: elementDetails[elementKeyToFullName[key]]?.name || key, count })); // Use map

     if (sortedThemes.length === 0) { personaThemesList.innerHTML = '<li>No strong themes (score >= 7.0) detected in your Core Concepts yet.</li>'; return; }
     sortedThemes.slice(0, 3).forEach(theme => { const li = document.createElement('li'); li.textContent = `${theme.name} Focus (${theme.count} Core concepts)`; personaThemesList.appendChild(li); });
}


// --- Study Screen Functions ---
function displayElementEssenceStudy() { /* ... no changes needed ... */
     if (!elementEssenceDisplayStudy) return; elementEssenceDisplayStudy.innerHTML = '';
     elementNames.forEach(elName => {
         const key = elementNameToKey[elName]; const currentEssence = parseFloat(elementEssence[key] || 0); const canAfford = currentEssence >= RESEARCH_COST;
         const counter = document.createElement('div'); counter.classList.add('essence-counter'); counter.dataset.elementKey = key; // Use KEY in dataset
         counter.title = `Research ${elementDetails[elName]?.name || elName} (Cost: ${RESEARCH_COST})`; counter.classList.toggle('disabled', !canAfford);
         counter.innerHTML = `<span class="essence-icon" style="background-color: ${getElementColor(elName)};"></span><span class="essence-name">${elementDetails[elName]?.name || elName}</span><span class="essence-value">${currentEssence.toFixed(1)}</span><div class="essence-cost">Cost: ${RESEARCH_COST}</div>`;
         if (canAfford) { counter.addEventListener('click', handleResearchClick); } elementEssenceDisplayStudy.appendChild(counter);
     });
}
function handleResearchClick(event) { /* ... no changes needed ... */
    const elementKey = event.currentTarget.dataset.elementKey; // Get KEY
    if (!elementKey || event.currentTarget.classList.contains('disabled')) return;
    const currentEssence = parseFloat(elementEssence[elementKey] || 0);
    if (currentEssence >= RESEARCH_COST) { elementEssence[elementKey] = currentEssence - RESEARCH_COST; console.log(`Spent ${RESEARCH_COST} ${elementKey} Essence.`); displayElementEssenceStudy(); conductResearch(elementKey); updateMilestoneProgress('conductResearch', 1); }
    else { alert(`Not enough ${elementDetails[elementKeyToFullName[elementKey]]?.name || elementKey} Essence! Need ${RESEARCH_COST}.`); } // Improved alert
}
// *** FIX: Use elementKeyToFullName map ***
function conductResearch(elementKeyToResearch) { // Expects KEY
    const elementFullName = elementKeyToFullName[elementKeyToResearch]; // Use map
    if (!elementFullName) { console.error("Invalid key for research:", elementKeyToResearch); return; }
    console.log(`Researching: ${elementFullName} (Key: ${elementKeyToResearch})`); if (researchStatus) researchStatus.textContent = `Researching ${elementDetails[elementFullName]?.name || elementFullName}...`; if (researchModalContent) researchModalContent.innerHTML = '';
    const discoveredIds = new Set(discoveredConcepts.keys()); const undiscoveredPool = concepts.filter(c => !discoveredIds.has(c.id));
    if (undiscoveredPool.length === 0) {
        if (researchModalStatus) researchModalStatus.textContent = "All concepts have been discovered!";
        if (researchStatus) researchStatus.textContent = "Research complete. No more concepts to find.";
        if (researchModal) researchModal.classList.remove('hidden');
        if (popupOverlay) popupOverlay.classList.remove('hidden');
        return;
    }
    const currentAttunement = elementAttunement[elementKeyToResearch] || 0; // Use KEY for attunement check
    const priorityPool = []; const secondaryPool = []; const tertiaryPool = [...undiscoveredPool]; // Clone for modification

    // Categorize based on affinity to the researched element
    undiscoveredPool.forEach(c => {
        const score = c.elementScores?.[elementKeyToResearch] || 0;
        const primary = c.primaryElement === elementKeyToResearch;
        const indexInTertiary = tertiaryPool.findIndex(tc => tc.id === c.id); // Find in the clone

        if (primary || score >= 8.0) { // High affinity or primary element
            priorityPool.push(c);
            if (indexInTertiary > -1) tertiaryPool.splice(indexInTertiary, 1); // Remove from tertiary
        } else if (score >= 5.0) { // Moderate affinity
            secondaryPool.push(c);
             if (indexInTertiary > -1) tertiaryPool.splice(indexInTertiary, 1); // Remove from tertiary
        }
        // Else: leave in tertiaryPool (low affinity)
    });

    const selectedForOutput = [];
    const selectWeightedRandomFromPool = (pool) => { /* ... (Weighted selection logic unchanged - looks okay) ... */
        if (pool.length === 0) return null; let totalWeight = 0;
        const weightedPool = pool.map(card => { let weight = 1.0;
             // Rarity bonus scales with attunement (more likely to get rarer cards at higher attunement)
            const rarityBonus = 1 + (currentAttunement / MAX_ATTUNEMENT); // Simple linear scaling 1x to 2x
            if (card.rarity === 'uncommon') weight *= (1.5 * rarityBonus);
            if (card.rarity === 'rare') weight *= (2.0 * rarityBonus);
            totalWeight += weight; return { card, weight };
        });
        let randomPick = Math.random() * totalWeight; let chosenCard = null;
        for (let i = 0; i < weightedPool.length; i++) {
            const item = weightedPool[i];
            if (randomPick < item.weight) {
                chosenCard = item.card;
                // IMPORTANT: Remove the chosen card from the original pool array it came from
                const originalIndex = pool.findIndex(c => c.id === chosenCard.id);
                if (originalIndex > -1) pool.splice(originalIndex, 1);
                break;
            }
            randomPick -= item.weight;
        }
         // Fallback if weights/random fails somehow
        if (!chosenCard && pool.length > 0) {
            console.warn("Weighted selection fallback triggered.");
            const fallbackIndex = Math.floor(Math.random() * pool.length);
            chosenCard = pool[fallbackIndex];
            pool.splice(fallbackIndex, 1); // Remove from pool
        }
        return chosenCard;
    };

    // Select up to 3 cards, prioritizing pools
    for (let i = 0; i < 3; i++) {
         let selectedCard = selectWeightedRandomFromPool(priorityPool) || selectWeightedRandomFromPool(secondaryPool) || selectWeightedRandomFromPool(tertiaryPool);
         if (selectedCard) { selectedForOutput.push(selectedCard); } else { break; } // Stop if no more cards in any pool
    }

    if (selectedForOutput.length > 0) {
        if (researchModalStatus) researchModalStatus.textContent = `Discovered ${selectedForOutput.length} new concept(s)! Click card to view & add.`;
        if (researchModalContent) researchModalContent.innerHTML = ''; // Clear previous results
        selectedForOutput.forEach(concept => {
             // Render card in 'research-result' context (might need specific styling/click behavior)
             // For now, reuse standard renderCard, click will open detail popup
            const cardElement = renderCard(concept, 'research-result'); // Context allows potential specific handling
            if (researchModalContent) researchModalContent.appendChild(cardElement);
        });
        if (researchStatus) researchStatus.textContent = `Research complete. ${selectedForOutput.length} new concept(s) found! Check results.`;
        gainAttunementForAction('researchSuccess', elementKeyToResearch, 0.8); // Grant slightly more attunement for success
    }
    else {
        if (researchModalStatus) researchModalStatus.textContent = "No new concepts found this time.";
        if (researchStatus) researchStatus.textContent = "Research complete. No new concepts discovered.";
         gainAttunementForAction('researchFail', elementKeyToResearch, 0.2); // Grant tiny attunement even on failure
    }
    if (researchModal) researchModal.classList.remove('hidden'); if (popupOverlay) popupOverlay.classList.remove('hidden');
}


// --- Grimoire Functions ---
function displayGrimoire(filterType = "All", filterElement = "All", sortBy = "discovered", filterRarity = "All") {
     if (!grimoireContentDiv) return; grimoireContentDiv.innerHTML = '';
     if (discoveredConcepts.size === 0) { grimoireContentDiv.innerHTML = '<p style="text-align: center; color: #666;">Your Grimoire is empty. Discover concepts through Research in The Study.</p>'; /* Removed showScreen call here */ return; } // Don't switch screen here

     let discoveredArray = Array.from(discoveredConcepts.values()); // Get array of { concept, discoveredTime, artUnlocked }

     const conceptsToDisplay = discoveredArray.filter(data => {
         if (!data || !data.concept) return false; // Safety check
         const concept = data.concept;
         const typeMatch = (filterType === "All") || (concept.cardType === filterType);
         // FilterElement uses FULL NAME from dropdown value
         const elementMatch = (filterElement === "All") || (concept.primaryElement === elementNameToKey[filterElement]); // Compare primary KEY with converted filter name
         const rarityMatch = (filterRarity === "All") || (concept.rarity === filterRarity);
         return typeMatch && elementMatch && rarityMatch;
     });

     // Sorting logic (seems okay)
     if (sortBy === 'name') conceptsToDisplay.sort((a, b) => a.concept.name.localeCompare(b.concept.name));
     else if (sortBy === 'type') conceptsToDisplay.sort((a, b) => a.concept.cardType.localeCompare(b.concept.cardType) || a.concept.name.localeCompare(b.concept.name));
     else if (sortBy === 'rarity') { const order = { 'common': 1, 'uncommon': 2, 'rare': 3 }; conceptsToDisplay.sort((a, b) => (order[a.concept.rarity] || 0) - (order[b.concept.rarity] || 0) || a.concept.name.localeCompare(b.concept.name)); }
     else conceptsToDisplay.sort((a,b) => a.discoveredTime - b.discoveredTime); // Default sort by discovered time

     if (conceptsToDisplay.length === 0) { grimoireContentDiv.innerHTML = `<p style="text-align: center; color: #666;">No discovered concepts match the current filters.</p>`; }
     else { conceptsToDisplay.forEach(data => { const cardElement = renderCard(data.concept, 'grimoire'); grimoireContentDiv.appendChild(cardElement); }); }
     // Removed showScreen call from here, it's handled by the nav button listener
}

function populateGrimoireFilters() { /* ... no changes needed ... */
    if (grimoireTypeFilter) { grimoireTypeFilter.innerHTML = '<option value="All">All Types</option>'; cardTypeKeys.forEach(type => { const option = document.createElement('option'); option.value = type; option.textContent = type; grimoireTypeFilter.appendChild(option); }); }
    if (grimoireElementFilter) { grimoireElementFilter.innerHTML = '<option value="All">All Elements</option>'; elementNames.forEach(fullName => { const name = elementDetails[fullName]?.name || fullName; const option = document.createElement('option'); option.value = name; /* Use Full Name for filter value */ option.textContent = name; grimoireElementFilter.appendChild(option); }); }
    // Rarity filter is static HTML
}
function updateGrimoireCounter() { if (grimoireCountSpan) grimoireCountSpan.textContent = discoveredConcepts.size; }


// --- Card Rendering Function ---
// *** FIX: Use elementKeyToFullName map ***
function renderCard(concept, context = 'grimoire') {
    if (!concept || !concept.id) { console.warn("renderCard called with invalid concept:", concept); return document.createElement('div'); } // Basic validation

    const cardDiv = document.createElement('div'); cardDiv.classList.add('concept-card'); cardDiv.classList.add(`rarity-${concept.rarity || 'common'}`); cardDiv.dataset.conceptId = concept.id; cardDiv.title = `View ${concept.name}`;

    // Check discovery status *based on the map*
    const discoveredData = discoveredConcepts.get(concept.id);
    const isDiscovered = !!discoveredData; // Card is in the map
    const isCore = coreConcepts.has(concept.id); // Check core set
    const artUnlocked = discoveredData?.artUnlocked || false; // Check unlocked status from map data

    // Stamps based on current state
    const grimoireStampHTML = isDiscovered ? '<span class="grimoire-stamp" title="In Grimoire"><i class="fas fa-book-open"></i></span>' : '';
    const coreStampHTML = isCore ? '<span class="core-indicator" title="Core Concept">★</span>' : '';
    const cardTypeIcon = getCardTypeIcon(concept.cardType);

    // Affinities
    let affinitiesHTML = '';
    if (concept.elementScores) {
        Object.entries(concept.elementScores).forEach(([key, score]) => {
             const level = getAffinityLevel(score); // Returns "High", "Moderate", or null
             if (level && elementKeyToFullName[key]) { // Check if key is valid
                 const fullName = elementKeyToFullName[key]; // Use map
                 const color = getElementColor(fullName);
                 const levelClass = level === "High" ? "affinity-high" : ""; // Only add class for High
                 // Use icons for elements
                 affinitiesHTML += `<span class="affinity ${levelClass}" style="border-color: ${color}; color: ${color}; background-color: ${hexToRgba(color, 0.1)};" title="${elementDetails[fullName]?.name || fullName} Affinity: ${level}">
                                         <i class="${getElementIcon(fullName)}"></i> ${level.substring(0,1)}</span> `; // Show only H or M
             }
        });
    }

    const currentVisualHandle = artUnlocked ? (concept.visualHandleUnlocked || concept.visualHandle) : concept.visualHandle;
    // Use actual unlocked art handle if available, otherwise placeholder
    const visualContent = artUnlocked && concept.visualHandleUnlocked
         ? `<img src="placeholder_art/${concept.visualHandleUnlocked}.png" alt="${concept.name} Art" class="card-art-image">` // Placeholder IMG tag
         : `<i class="fas fa-${artUnlocked ? 'star' : 'question'} card-visual-placeholder ${artUnlocked ? 'card-art-unlocked' : ''}" title="${currentVisualHandle}"></i>`; // Placeholder icon

    cardDiv.innerHTML = `
        <div class="card-header">
            <i class="${cardTypeIcon} card-type-icon" title="${concept.cardType}"></i>
            <span class="card-name">${concept.name}</span>
            <span class="card-stamps">${coreStampHTML}${grimoireStampHTML}</span>
        </div>
        <div class="card-visual">
             ${visualContent}
        </div>
        <div class="card-footer">
            <div class="card-affinities">${affinitiesHTML || '<small style="color:#888; font-style: italic;">Basic Affinity</small>'}</div>
            <p class="card-brief-desc">${concept.briefDescription || '...'}</p>
        </div>`;

     // Add click listener unless specified otherwise
     if (context !== 'no-click') {
         cardDiv.addEventListener('click', () => showConceptDetailPopup(concept.id));
     }

     // Special handling for research results? (e.g., make clicking add it)
     if (context === 'research-result') {
         cardDiv.title = `Click to view details for ${concept.name}`;
         // The popup will handle the 'Add to Grimoire' button
     }

    return cardDiv;
}


// --- Concept Detail Pop-up Logic ---
function showConceptDetailPopup(conceptId) {
     const conceptData = concepts.find(c => c.id === conceptId);
     const discoveredData = discoveredConcepts.get(conceptId); // Check if discovered

     if (!conceptData) { console.error(`Concept ${conceptId} not found!`); return; }

     currentlyDisplayedConceptId = conceptId; // Store ID for actions

     // Populate static info
     if (popupConceptName) popupConceptName.textContent = conceptData.name;
     if (popupConceptType) popupConceptType.textContent = conceptData.cardType;
     if (popupCardTypeIcon) popupCardTypeIcon.className = `${getCardTypeIcon(conceptData.cardType)} card-type-icon`; // Update icon class
     if (popupDetailedDescription) popupDetailedDescription.textContent = conceptData.detailedDescription || "No detailed description available.";

     // Populate Visual
     const artUnlocked = discoveredData?.artUnlocked || false;
     const currentVisualHandle = artUnlocked ? (conceptData.visualHandleUnlocked || conceptData.visualHandle) : conceptData.visualHandle;
     if (popupCardVisual) {
         popupCardVisual.className = `fa-solid ${artUnlocked ? 'fa-star card-art-unlocked' : 'fa-image card-visual-placeholder'}`; // Use FontAwesome icons or clear for image
         popupCardVisual.title = currentVisualHandle || "Visual representation";
          // Clear previous image if any
         const existingImg = popupCardVisual.parentNode.querySelector('.card-art-image');
         if (existingImg) existingImg.remove();
         // Add image if art is unlocked and handle exists
         if (artUnlocked && conceptData.visualHandleUnlocked) {
            popupCardVisual.className = ''; // Remove icon classes
            const img = document.createElement('img');
            img.src = `placeholder_art/${conceptData.visualHandleUnlocked}.png`; // Use placeholder path
            img.alt = `${conceptData.name} Art`;
            img.classList.add('card-art-image'); // Add class for styling
             popupCardVisual.parentNode.insertBefore(img, popupCardVisual); // Add image before placeholder
         }
     }


     // Calculate and display resonance
     const distance = euclideanDistance(userScores, conceptData.elementScores);
     displayPopupResonance(distance);

     // Display recipe comparison
     displayPopupRecipeComparison(conceptData);

     // Display related concepts
     displayPopupRelatedConcepts(conceptData);

     // Display Evolution section if applicable
     displayEvolutionSection(conceptData, discoveredData);

     // Update button states
     updateGrimoireButtonStatus(conceptId);
     updateCoreButtonStatus(conceptId);


     if (conceptDetailPopup) conceptDetailPopup.classList.remove('hidden');
     if (popupOverlay) popupOverlay.classList.remove('hidden');
 }

function displayPopupResonance(distance) { /* ... no changes needed ... */
    if (!popupResonanceSummary) return;
    let resonanceLabel = "Low"; let resonanceClass = "resonance-low";
    if (distance === Infinity || isNaN(distance)) { resonanceLabel = "N/A"; resonanceClass = ""; }
    else if (distance < 2.5) { resonanceLabel = "Very High"; resonanceClass = "resonance-high"; } // Tighter threshold for Very High
    else if (distance < 4.0) { resonanceLabel = "High"; resonanceClass = "resonance-high"; }
    else if (distance < 6.0) { resonanceLabel = "Moderate"; resonanceClass = "resonance-medium"; }
    // Default is Low
    popupResonanceSummary.innerHTML = `Resonance with You: <span class="resonance-indicator ${resonanceClass}">${resonanceLabel}</span> (Dist: ${distance.toFixed(1)})`;
}
// *** FIX: Use elementKeyToFullName map ***
function displayPopupRecipeComparison(conceptData) {
    if (!popupConceptProfile || !popupUserComparisonProfile || !popupComparisonHighlights) return;

    popupConceptProfile.innerHTML = ''; popupUserComparisonProfile.innerHTML = ''; popupComparisonHighlights.innerHTML = '';
    let highlightsHTML = '<p><strong>Key Alignments & Differences:</strong></p>'; let hasHighlights = false;

    const conceptScores = conceptData.elementScores || {};
    const userCompScores = userScores || {}; // Use the global userScores

    elementNames.forEach(elName => {
        const key = elementNameToKey[elName];
        const fullName = elementKeyToFullName[key]; // Use map
        if (!fullName) return; // Skip if key is invalid

        const conceptScore = conceptScores[key];
        const userScore = userCompScores[key];
        const conceptLabel = getScoreLabel(conceptScore);
        const userLabel = getScoreLabel(userScore);

        const conceptBarWidth = conceptScore ? (conceptScore / 10) * 100 : 0;
        const userBarWidth = userScore ? (userScore / 10) * 100 : 0;
        const color = getElementColor(fullName);

        popupConceptProfile.innerHTML += `<div><strong>${elementDetails[fullName]?.name.substring(0, 11) || elName}:</strong> <span>${conceptScore?.toFixed(1) ?? '?'}</span> <div class="score-bar-container"><div style="width: ${conceptBarWidth}%; background-color: ${color};"></div></div></div>`;
        popupUserComparisonProfile.innerHTML += `<div><strong>${elementDetails[fullName]?.name.substring(0, 11) || elName}:</strong> <span>${userScore?.toFixed(1) ?? '?'}</span> <div class="score-bar-container"><div style="width: ${userBarWidth}%; background-color: ${color};"></div></div></div>`;

        // Highlight significant matches or mismatches
        const diff = Math.abs(conceptScore - userScore);
        if (conceptScore >= 7 && userScore >= 7) { // Both high
            highlightsHTML += `<p>• <strong class="match">Strong Alignment</strong> in ${elementDetails[fullName]?.name || elName} (${userLabel})</p>`; hasHighlights = true;
        } else if (conceptScore <= 3 && userScore <= 3) { // Both low
             highlightsHTML += `<p>• <strong class="match">Shared Low Emphasis</strong> in ${elementDetails[fullName]?.name || elName} (${userLabel})</p>`; hasHighlights = true;
        } else if (diff >= 4) { // Significant difference
             const direction = conceptScore > userScore ? "higher" : "lower";
             highlightsHTML += `<p>• <strong class="mismatch">Notable Difference</strong> in ${elementDetails[fullName]?.name || elName} (Concept is ${conceptLabel}, You are ${userLabel})</p>`; hasHighlights = true;
        }
    });
    if (!hasHighlights) highlightsHTML += '<p><em>No strong alignments or major differences detected.</em></p>';
    popupComparisonHighlights.innerHTML = highlightsHTML;
}
function displayPopupRelatedConcepts(conceptData) { /* ... no changes needed ... */
     if (!popupRelatedConceptsList) return; popupRelatedConceptsList.innerHTML = '';
     if (conceptData.relatedIds && conceptData.relatedIds.length > 0) {
         conceptData.relatedIds.forEach(relatedId => { const relatedConcept = concepts.find(c => c.id === relatedId); if (relatedConcept) { const li = document.createElement('li'); li.textContent = relatedConcept.name; li.dataset.conceptId = relatedId; li.addEventListener('click', handleRelatedConceptClick); popupRelatedConceptsList.appendChild(li); } });
     } else { popupRelatedConceptsList.innerHTML = '<li>None specified</li>'; }
}
function handleRelatedConceptClick(event) { /* ... no changes needed ... */
     const conceptId = event.target.dataset.conceptId; if (!conceptId) return;
     const numericId = parseInt(conceptId);
     if (!isNaN(numericId)) { showConceptDetailPopup(numericId); } // Show detail for the clicked related concept
}
// *** FIX: Use elementKeyToFullName map ***
function displayEvolutionSection(conceptData, discoveredData) {
    if (!popupEvolutionSection || !evolveArtButton || !evolveEligibility || !evolveCostSpan) return;

    const isDiscovered = !!discoveredData;
    const canUnlock = conceptData.canUnlockArt;
    const alreadyUnlocked = discoveredData?.artUnlocked || false;
    const isCore = coreConcepts.has(conceptData.id);
    const requiredElement = conceptData.primaryElement; // Use primary element key
    const fullName = elementKeyToFullName[requiredElement]; // Use map
    const currentEssence = elementEssence[requiredElement] || 0;
    const cost = ART_EVOLVE_COST;
    const hasEnoughEssence = currentEssence >= cost;
    // Simplified reflection check: Assume any reflection contributes (Placeholder)
    const hasReflected = seenPrompts.size > 0; // Very basic check

    evolveCostSpan.textContent = cost; // Display cost

    if (isDiscovered && canUnlock && !alreadyUnlocked) {
        popupEvolutionSection.classList.remove('hidden');
        let eligibilityText = ''; let canEvolve = true;

        if (!isCore) { eligibilityText += '<li>Mark as Core Concept</li>'; canEvolve = false; } else { eligibilityText += '<li><i class="fas fa-check"></i> Marked as Core</li>'; }
        if (!hasReflected) { eligibilityText += '<li>Engage in Reflection</li>'; canEvolve = false; } else { eligibilityText += '<li><i class="fas fa-check"></i> Reflection Engaged</li>'; }
        if (!hasEnoughEssence) { eligibilityText += `<li>Need ${cost} ${elementDetails[fullName]?.name || requiredElement} Essence (Have ${currentEssence.toFixed(1)})</li>`; canEvolve = false;} else { eligibilityText += `<li><i class="fas fa-check"></i> Enough Essence</li>`; }

        evolveEligibility.innerHTML = `<ul>${eligibilityText}</ul>`;
        evolveEligibility.classList.remove('hidden');
        evolveArtButton.disabled = !canEvolve;
        // Add listener if not already added (or manage listeners better)
        evolveArtButton.onclick = () => attemptArtEvolution(conceptData.id, requiredElement, cost);

    } else {
        popupEvolutionSection.classList.add('hidden');
        evolveArtButton.disabled = true;
        evolveEligibility.classList.add('hidden');
        evolveArtButton.onclick = null; // Remove listener
    }
}
function attemptArtEvolution(conceptId, essenceElementKey, cost) { /* ... (logic seems okay, uses key) ... */
     console.log(`Attempting art evolution for ${conceptId} using ${essenceElementKey} essence.`);
     const discoveredData = discoveredConcepts.get(conceptId);
     if (!discoveredData || !discoveredData.concept || discoveredData.artUnlocked) { console.error("Cannot evolve: Not discovered or already unlocked."); return; }
     const concept = discoveredData.concept;
     if (!concept.canUnlockArt) { console.error("Cannot evolve: Art is not unlockable for this concept."); return; }

     const isCore = coreConcepts.has(conceptId);
     const hasReflected = seenPrompts.size > 0; // Simplified check
     const currentEssence = elementEssence[essenceElementKey] || 0;

     if (isCore && hasReflected && currentEssence >= cost) {
         // Deduct cost
         elementEssence[essenceElementKey] = currentEssence - cost;
         // Update discovered data
         discoveredData.artUnlocked = true;
         discoveredConcepts.set(conceptId, discoveredData); // Update map entry

         console.log(`Art unlocked for ${concept.name}!`);
         showTemporaryMessage(`Enhanced Art Unlocked for ${concept.name}!`);

         // Update displays
         displayElementEssenceStudy(); // Refresh study essence
         displayElementEssencePersona(); // Refresh persona essence
         if (currentlyDisplayedConceptId === conceptId) {
             displayEvolutionSection(concept, discoveredData); // Refresh evolution section in popup
             // Refresh visual in popup
             const artUnlocked = discoveredData?.artUnlocked || false;
             const currentVisualHandle = artUnlocked ? (concept.visualHandleUnlocked || concept.visualHandle) : concept.visualHandle;
             if (popupCardVisual) {
                 // Clear previous image if any
                 const existingImg = popupCardVisual.parentNode.querySelector('.card-art-image');
                 if (existingImg) existingImg.remove();
                 // Add image if art is unlocked and handle exists
                 if (artUnlocked && concept.visualHandleUnlocked) {
                    popupCardVisual.className = ''; // Remove icon classes
                    const img = document.createElement('img');
                    img.src = `placeholder_art/${concept.visualHandleUnlocked}.png`;
                    img.alt = `${concept.name} Art`;
                    img.classList.add('card-art-image');
                    popupCardVisual.parentNode.insertBefore(img, popupCardVisual);
                 } else {
                     popupCardVisual.className = `fa-solid fa-star card-visual-placeholder card-art-unlocked`; // Fallback icon if no image
                 }
                 popupCardVisual.title = currentVisualHandle || "Visual representation";
             }
         }
         if (grimoireScreen.classList.contains('current')) {
            displayGrimoire(grimoireTypeFilter.value, grimoireElementFilter.value, grimoireSortOrder.value, grimoireRarityFilter.value); // Refresh grimoire if open
         }

          gainAttunementForAction('artEvolve', essenceElementKey, 1.5); // Attunement bonus
          updateMilestoneProgress('evolveArt', 1); // Track milestone

     } else {
         console.warn("Evolution conditions not met.");
         alert("Cannot unlock art yet. Check requirements: Core Status, Reflection, Essence.");
     }
}


// --- Grimoire/Core Button & State Logic ---

// *** DEBUG: Add detailed logging to grantEssenceForConcept ***
function grantEssenceForConcept(concept, multiplier = 1.0) {
    if (!concept || !concept.elementScores) {
        console.warn(`[grantEssence] Invalid concept or missing scores for ${concept?.name || 'Unknown Concept'}`);
        return;
    }
    console.log(`[grantEssence] Called for: ${concept.name} (ID: ${concept.id}), Multiplier: ${multiplier}`);
    let grantedAny = false;

    for (const key in concept.elementScores) {
        // Use hasOwnProperty on the elementEssence object itself to ensure the key is valid ('A', 'I', etc.)
        if (elementEssence.hasOwnProperty(key)) {
            const score = concept.elementScores[key];
            if (typeof score !== 'number' || isNaN(score)) {
                console.warn(` -> Invalid score (${score}) for key ${key} in concept ${concept.name}. Skipping.`);
                continue; // Skip this element key if score is invalid
            }

            // Calculate gain (simple scaling based on score, plus multiplier)
            // Base gain even for score 0, scaling up to 0.2 for score 10
            let baseGain = 0.1 + (score / 100.0); // e.g., Score 5 -> 0.15, Score 10 -> 0.2
            let essenceToGrant = baseGain * multiplier;

             // Make sure essenceToGrant is a valid number
             if (isNaN(essenceToGrant)) {
                 console.warn(` -> Calculated essenceToGrant is NaN for key ${key} (Base: ${baseGain}, Mult: ${multiplier}). Skipping.`);
                 continue;
             }

             // Ensure the current value is treated as a number
             let currentVal = parseFloat(elementEssence[key] || 0);
             if (isNaN(currentVal)) {
                 console.warn(` -> Current essence value for key ${key} is NaN. Resetting to 0.`);
                 currentVal = 0;
             }

             // Add the granted essence
             elementEssence[key] = currentVal + essenceToGrant;
             console.log(` -> Granted ${essenceToGrant.toFixed(3)} for key ${key}. New total: ${elementEssence[key].toFixed(3)}`);
             grantedAny = true;

        } else {
             // This case means the concept has an elementScore key (e.g., 'X') that doesn't exist in our elementEssence object
             console.warn(` -> Concept ${concept.name} has score for invalid key: ${key}`);
        }
    }

    if (!grantedAny) {
        console.warn(`[grantEssence] No essence was granted for ${concept.name}. Check element keys and scores.`);
    } else {
         // Optionally, trigger UI update immediately if needed, though usually batched later
         // displayElementEssenceStudy();
         // displayElementEssencePersona();
    }
}

function addToGrimoire() {
    if (currentlyDisplayedConceptId === null) return;
    const concept = concepts.find(c => c.id === currentlyDisplayedConceptId);
    if (!concept) { console.error("Concept not found for adding to grimoire"); return; }

    if (!discoveredConcepts.has(concept.id)) {
        console.log(`Adding ${concept.name} to Grimoire.`);
        discoveredConcepts.set(concept.id, { concept: concept, discoveredTime: Date.now(), artUnlocked: false });
        grantEssenceForConcept(concept, 1.0); // Grant full essence on manual add
        gainAttunementForAction('addToGrimoire', concept.primaryElement, 0.6); // Attunement bonus
        updateGrimoireCounter();
        updateGrimoireButtonStatus(concept.id); // Update button in popup
        updateCoreButtonStatus(concept.id); // Show core button now
        displayElementEssenceStudy(); // Update study display
        displayElementEssencePersona(); // Update persona display
        checkAndApplySynergyBonus(concept, 'add'); // Check synergy
         checkTriggerReflectionPrompt('add'); // Check if reflection triggers
         updateMilestoneProgress('addToGrimoire', 1); // Track milestone
         updateMilestoneProgress('discoveredConcepts.size', discoveredConcepts.size); // Update size milestone

        // Optional: Refresh grimoire view if currently open
        if (grimoireScreen.classList.contains('current')) {
             displayGrimoire(grimoireTypeFilter.value, grimoireElementFilter.value, grimoireSortOrder.value, grimoireRarityFilter.value);
        }
         showTemporaryMessage(`${concept.name} added to Grimoire!`);

    } else {
        console.log(`${concept.name} is already in the Grimoire.`);
        showTemporaryMessage(`${concept.name} is already in your Grimoire.`);
    }
}
function toggleCoreConcept() { /* ... (logic seems okay, uses keys internally via grant/attunement) ... */
    if (currentlyDisplayedConceptId === null) return;
    const discoveredData = discoveredConcepts.get(currentlyDisplayedConceptId);
    if (!discoveredData || !discoveredData.concept) { console.error("Concept not found or not discovered."); return; }
    const concept = discoveredData.concept;

    if (coreConcepts.has(concept.id)) {
        coreConcepts.delete(concept.id);
        console.log(`Removed ${concept.name} from Core Concepts.`);
        showTemporaryMessage(`${concept.name} removed from Core.`);
        // No essence penalty for removing? Or small cost? For now, no cost.
    } else {
        coreConcepts.add(concept.id);
        console.log(`Marked ${concept.name} as Core Concept.`);
        showTemporaryMessage(`${concept.name} marked as Core!`);
        grantEssenceForConcept(concept, 0.2); // Small essence bonus for marking core
        gainAttunementForAction('markCore', concept.primaryElement, 1.0); // Attunement bonus
        checkAndApplySynergyBonus(concept, 'core'); // Check synergy
        updateMilestoneProgress('markCore', 1);
        updateMilestoneProgress('coreConcepts.size', coreConcepts.size);
    }
    updateCoreButtonStatus(concept.id); // Update button text/state
    displayCoreConceptsPersona(); // Refresh persona display
    synthesizeAndDisplayThemesPersona(); // Refresh themes
    displayElementEssenceStudy(); // Refresh study essence display
    displayElementEssencePersona(); // Refresh persona essence display
     // Refresh card render if Grimoire is visible
     if (grimoireScreen.classList.contains('current')) {
         displayGrimoire(grimoireTypeFilter.value, grimoireElementFilter.value, grimoireSortOrder.value, grimoireRarityFilter.value);
     }
}
function checkAndApplySynergyBonus(concept, action) { /* ... (logic seems okay, uses keys) ... */
    let synergyFound = false; const bonusMultiplier = 0.2; // Extra essence multiplier
    const messageAction = action === 'add' ? 'added' : 'marked core';
    // Check synergy with CORE concepts only when adding a NEW concept or marking one CORE
    if (action === 'add' || action === 'core') {
         coreConcepts.forEach(coreId => {
             if (coreId === concept.id) return; // Don't compare to self
             const coreConceptData = discoveredConcepts.get(coreId);
             if (!coreConceptData) return;
             const coreConcept = coreConceptData.concept;
             // Check if the new/cored concept is related to an existing core concept
             if (coreConcept.relatedIds && coreConcept.relatedIds.includes(concept.id)) {
                 synergyFound = true;
                 console.log(`Synergy! ${concept.name} relates to Core Concept ${coreConcept.name}. Granting bonus essence.`);
                 grantEssenceForConcept(concept, bonusMultiplier); // Grant bonus based on *new* concept's scores
                 grantEssenceForConcept(coreConcept, bonusMultiplier); // Grant bonus based on *related* core concept's scores
                 gainAttunementForAction('synergy', concept.primaryElement, 0.5);
                 gainAttunementForAction('synergy', coreConcept.primaryElement, 0.5);
             }
             // Check reverse relationship too
              if (concept.relatedIds && concept.relatedIds.includes(coreId)) {
                 synergyFound = true;
                 console.log(`Synergy! ${coreConcept.name} relates to newly ${messageAction} ${concept.name}. Granting bonus essence.`);
                 grantEssenceForConcept(concept, bonusMultiplier);
                 grantEssenceForConcept(coreConcept, bonusMultiplier);
                  gainAttunementForAction('synergy', concept.primaryElement, 0.5);
                  gainAttunementForAction('synergy', coreConcept.primaryElement, 0.5);
             }
         });
         if(synergyFound) showTemporaryMessage("Synergy Bonus! Essence granted.");
    }
}
function updateGrimoireButtonStatus(conceptId) { /* ... no changes needed ... */
    if (!addToGrimoireButton) return;
    const isDiscovered = discoveredConcepts.has(conceptId);
    addToGrimoireButton.disabled = isDiscovered;
    addToGrimoireButton.textContent = isDiscovered ? "In Grimoire" : "Add to Grimoire";
    addToGrimoireButton.classList.toggle('added', isDiscovered);
}
function updateCoreButtonStatus(conceptId) { /* ... no changes needed ... */
    if (!markAsCoreButton) return;
    const isDiscovered = discoveredConcepts.has(conceptId);
    const isCore = coreConcepts.has(conceptId);

    // Only show the button if the concept is actually discovered
    markAsCoreButton.classList.toggle('hidden', !isDiscovered);

    if (isDiscovered) {
        markAsCoreButton.textContent = isCore ? "Remove Core" : "Mark as Core";
        markAsCoreButton.classList.toggle('marked', isCore);
    }
}

// --- Reflection Prompts ---
function checkTriggerReflectionPrompt(triggerAction = 'other') { /* ... (logic seems okay) ... */
    if (promptCooldownActive) return; // Don't trigger if cooling down

    // Trigger on adding 3 unique cards OR completing questionnaire
    if (triggerAction === 'add') cardsAddedSinceLastPrompt++;
    if (triggerAction === 'completeQuestionnaire') cardsAddedSinceLastPrompt = 99; // Force trigger after questionnaire

    const triggerThreshold = 3;
    if (cardsAddedSinceLastPrompt >= triggerThreshold) {
        displayReflectionPrompt();
        cardsAddedSinceLastPrompt = 0; // Reset counter
        promptCooldownActive = true; // Start cooldown
        setTimeout(() => { promptCooldownActive = false; console.log("Reflection cooldown ended."); }, 1000 * 60 * 5); // 5 min cooldown
    }
}
function displayReflectionPrompt() { /* ... (logic seems okay) ... */
    // Find elements with highest attunement OR lowest attunement OR least reflected
    let possibleElements = elementNames.filter(elName => {
         // Basic check: filter out elements with no prompts defined
         return reflectionPrompts[elName] && reflectionPrompts[elName].length > 0;
    });
    if (possibleElements.length === 0) { console.warn("No reflection prompts available for any element."); return; }

    // Simple strategy: pick a random element for now
    const targetElementName = possibleElements[Math.floor(Math.random() * possibleElements.length)];
    const promptsForElement = reflectionPrompts[targetElementName] || [];
    const availablePrompts = promptsForElement.filter(p => !seenPrompts.has(p.id));

    let selectedPrompt;
    if (availablePrompts.length > 0) {
        selectedPrompt = availablePrompts[Math.floor(Math.random() * availablePrompts.length)];
    } else {
        // If all seen for this element, pick a random one again (allow repeats if necessary)
        if (promptsForElement.length > 0) {
             console.log(`All prompts seen for ${targetElementName}, showing random.`);
             selectedPrompt = promptsForElement[Math.floor(Math.random() * promptsForElement.length)];
        } else {
            console.error(`No prompts defined for randomly selected element ${targetElementName}?`);
            return; // Should not happen based on filter above
        }
    }

    if (!selectedPrompt) { console.error("Could not select a reflection prompt."); return; }

    currentReflectionElement = targetElementName; // Store full name
    currentPromptId = selectedPrompt.id;

    if (reflectionElement) reflectionElement.textContent = elementDetails[targetElementName]?.name || targetElementName;
    if (reflectionPromptText) reflectionPromptText.textContent = selectedPrompt.text;
    if (reflectionCheckbox) reflectionCheckbox.checked = false;
    if (confirmReflectionButton) confirmReflectionButton.disabled = true;
    // Calculate reward based on attunement? For now, fixed.
     const rewardAmount = 2.0; // Example fixed reward
     if (reflectionRewardAmount) reflectionRewardAmount.textContent = rewardAmount;


    if (reflectionModal) reflectionModal.classList.remove('hidden');
    if (popupOverlay) popupOverlay.classList.remove('hidden');
}
// *** FIX: Use elementNameToKey for essence gain ***
function handleConfirmReflection() {
    if (!currentReflectionElement || !currentPromptId || !reflectionCheckbox || !reflectionCheckbox.checked) return;

    console.log(`Reflection confirmed for ${currentReflectionElement}, prompt ID: ${currentPromptId}`);
    seenPrompts.add(currentPromptId); // Track seen prompt

    // Grant Rewards
    const rewardAmount = parseFloat(document.getElementById('reflectionRewardAmount')?.textContent || 2.0);
    const elementKey = elementNameToKey[currentReflectionElement]; // Use map to get key

    if (elementKey && elementEssence.hasOwnProperty(elementKey)) {
        let currentVal = parseFloat(elementEssence[elementKey] || 0);
        elementEssence[elementKey] = currentVal + rewardAmount;
        console.log(`Granted ${rewardAmount} ${elementKey} Essence for reflection.`);
        displayElementEssenceStudy(); // Update UI
        displayElementEssencePersona();
    } else {
         console.warn(`Could not grant essence reward - invalid key for element: ${currentReflectionElement}`);
    }

    // Grant Attunement (uses currentReflectionElement full name)
    gainAttunementForAction('completeReflection', null, 1.0); // Let gainAttunement handle the key lookup

     updateMilestoneProgress('completeReflection', 1);

    hidePopups(); // Close the modal
    showTemporaryMessage("Reflection complete! Essence & Attunement gained.");
}


// --- Rituals & Milestones ---
function displayDailyRituals() { /* ... (placeholder logic seems okay) ... */
     if (!dailyRitualsDisplay) return; dailyRitualsDisplay.innerHTML = '';
     if (!dailyRituals || dailyRituals.length === 0) { dailyRitualsDisplay.innerHTML = '<li>No rituals defined.</li>'; return; }

     dailyRituals.forEach(ritual => {
         const isCompleted = completedRituals.daily[ritual.id] || false; // Check completion status (needs persistence)
         const li = document.createElement('li');
         li.classList.toggle('completed', isCompleted);
         let rewardText = '';
         if (ritual.reward) {
            if (ritual.reward.type === 'essence') rewardText = `(+${ritual.reward.amount} ${ritual.reward.element} Essence)`;
            if (ritual.reward.type === 'attunement') rewardText = `(+${ritual.reward.amount} Attunement)`;
         }
         li.innerHTML = `${ritual.description} <span class="ritual-reward">${rewardText}</span>`;
         dailyRitualsDisplay.appendChild(li);
     });
}
function checkAndUpdateRituals(action, details = {}) { /* ... (placeholder logic) ... */
     console.log("Checking rituals for action:", action, details);
     // This needs proper implementation based on tracked actions/state
     // Example (very basic):
     dailyRituals.forEach(ritual => {
        if (!completedRituals.daily[ritual.id]) { // If not already complete today
            if (ritual.track.action === action) {
                 // Increment progress (needs better tracking state)
                 // If progress >= count, mark complete
                 // completedRituals.daily[ritual.id] = true;
                 // displayDailyRituals(); // Update UI
                 // Grant reward...
            }
        }
     });
}
function displayMilestones() { /* ... (logic seems okay) ... */
    if (!milestonesDisplay) return; milestonesDisplay.innerHTML = '';
    if (achievedMilestones.size === 0) { milestonesDisplay.innerHTML = '<li>No milestones achieved yet.</li>'; return; }
    achievedMilestones.forEach(milestoneId => { const milestone = milestones.find(m => m.id === milestoneId); if (milestone) { const li = document.createElement('li'); li.textContent = `✓ ${milestone.description}`; milestonesDisplay.appendChild(li); } });
}
// *** FIX: Use elementNameToKey for reward key ***
function updateMilestoneProgress(trackType, currentValue) {
     // console.log("Checking Milestones:", trackType, currentValue);
     milestones.forEach(m => {
         if (!achievedMilestones.has(m.id)) { // If not already achieved
             let achieved = false;
             if (m.track.action === trackType) {
                 // Simple count check (needs proper counter state)
                 // Assume currentValue is the total count for now
                 if (currentValue >= m.track.count) achieved = true;
             } else if (m.track.state === trackType) {
                  // State check (e.g., discoveredConcepts.size)
                 if (m.track.condition === "any") {
                     // Check if *any* value in the state object meets threshold
                     if (typeof currentValue === 'object') {
                         for (const key in currentValue) { if (currentValue[key] >= m.track.threshold) { achieved = true; break; } }
                     }
                 } else {
                     // Direct value comparison
                     if (currentValue >= m.track.threshold) achieved = true;
                 }
             }

             if (achieved) {
                 console.log("Milestone Achieved!", m.description);
                 achievedMilestones.add(m.id);
                 displayMilestones(); // Update display
                 showMilestoneAlert(m.description); // Show alert

                 // Grant Reward
                 if (m.reward) {
                     if (m.reward.type === 'essence') {
                         const amount = m.reward.amount || 0;
                         if (m.reward.element === 'All') {
                            Object.keys(elementEssence).forEach(key => elementEssence[key] += amount);
                            console.log(`Granted ${amount} All Essence`);
                         } else if (m.reward.element === 'Random') {
                             const keys = Object.keys(elementEssence);
                             const randomKey = keys[Math.floor(Math.random() * keys.length)];
                             elementEssence[randomKey] += amount;
                              console.log(`Granted ${amount} ${randomKey} Essence`);
                         } else {
                              const key = m.reward.element; // Assume key is provided directly
                              if (elementEssence.hasOwnProperty(key)) {
                                 elementEssence[key] += amount;
                                 console.log(`Granted ${amount} ${key} Essence`);
                              } else { console.warn(`Invalid essence key in milestone reward: ${key}`);}
                         }
                         displayElementEssenceStudy(); // Update UI
                         displayElementEssencePersona();
                     } else if (m.reward.type === 'attunement') {
                          // Grant attunement using gainAttunementForAction
                          gainAttunementForAction('milestone', m.reward.element || 'All', m.reward.amount || 0);
                     } else if (m.reward.type === 'message') {
                         // Message is shown via alert, nothing more needed here maybe
                     }
                 }
             }
         }
     });
}
function showMilestoneAlert(text) { /* ... (logic seems okay) ... */
     if (!milestoneAlert || !milestoneAlertText) return;
     milestoneAlertText.textContent = `Milestone: ${text}`;
     milestoneAlert.classList.remove('hidden');
     // Auto-hide after a few seconds?
     setTimeout(hideMilestoneAlert, 5000);
}
function hideMilestoneAlert() { /* ... (logic seems okay) ... */
     if (milestoneAlert) milestoneAlert.classList.add('hidden');
}
function showTemporaryMessage(message, duration = 3000) { /* ... (logic seems okay) ... */
     // Simple implementation: use console for now, could be a toast notification
     console.info(`Message: ${message}`);
     // Future: implement a proper toast notification element
}

// --- Reset App ---
function resetApp() { /* ... no changes needed ... */
    if (confirm("Are you sure you want to reset all progress? This cannot be undone.")) {
        console.log("Resetting application state...");
        // Clear local storage if implemented
        // Reset global variables
        initializeQuestionnaire(); // This handles resetting most state vars and UI
        // Ensure initial screen is shown
        showScreen('welcomeScreen');
    }
}

// --- Daily Login Check ---
function checkForDailyLogin() { /* ... (placeholder logic seems okay) ... */
     const today = new Date().toDateString();
     if (lastLoginDate !== today) {
         console.log("First login of the day detected.");
         // Reset daily ritual completion status (needs persistence)
         completedRituals.daily = {};
         lastLoginDate = today; // Update last login (needs persistence)
         displayDailyRituals(); // Refresh display

         // Potential daily login bonus?
         // gainAttunementForAction('dailyLogin', 'All', 0.2);
         // grantEssence...
          showTemporaryMessage("Daily rituals reset.");
     }
}

// --- Event Listeners (MUST BE AT THE END) ---
document.addEventListener('DOMContentLoaded', () => {
    console.log("DOM Fully Loaded. Initializing Card Concept Expanded...");

    // --- Navigation Buttons ---
    navButtons.forEach(button => {
        button.addEventListener('click', () => {
            const targetScreenId = button.dataset.target;
            if (!document.getElementById(targetScreenId)) {
                console.error(`Target screen #${targetScreenId} not found!`);
                return;
            }
            // Refresh content specific to the target screen *before* showing it
            if (targetScreenId === 'personaScreen') { displayPersonaScreen(); }
            if (targetScreenId === 'studyScreen') { displayElementEssenceStudy(); displayDailyRituals(); }
            if (targetScreenId === 'grimoireScreen') { displayGrimoire(grimoireTypeFilter.value, grimoireElementFilter.value, grimoireSortOrder.value, grimoireRarityFilter.value); }

            showScreen(targetScreenId); // Switch the visible screen
        });
    });

    // --- Questionnaire Buttons ---
    if (startButton) startButton.addEventListener('click', initializeQuestionnaire); else console.error("Start button not found!");
    if (nextElementButton) nextElementButton.addEventListener('click', nextElement); else console.error("Next button not found!");
    if (prevElementButton) prevElementButton.addEventListener('click', prevElement); else console.error("Prev button not found!");

    // --- Persona Screen Button ---
    if (restartButtonPersona) restartButtonPersona.addEventListener('click', resetApp); else console.error("Restart button (Persona) not found!");

    // --- Popup Close Buttons ---
    if (closePopupButton) closePopupButton.addEventListener('click', hidePopups); else console.error("Close Popup button not found!");
    if (popupOverlay) popupOverlay.addEventListener('click', hidePopups); else console.error("Popup Overlay not found!");
    if (closeResearchModalButton) closeResearchModalButton.addEventListener('click', hidePopups); else console.error("Close Research Modal button not found!");
    if (closeReflectionModalButton) closeReflectionModalButton.addEventListener('click', hidePopups); else console.error("Close Reflection Modal button not found!");
    if (closeMilestoneAlertButton) closeMilestoneAlertButton.addEventListener('click', hideMilestoneAlert); else console.error("Close Milestone Alert button not found!");

    // --- Concept Detail Popup Buttons ---
    if (addToGrimoireButton) addToGrimoireButton.addEventListener('click', addToGrimoire); else console.error("Add to Grimoire button not found!");
    if (markAsCoreButton) markAsCoreButton.addEventListener('click', toggleCoreConcept); else console.error("Mark as Core button not found!");
    // Note: Evolve button listener is added dynamically in displayEvolutionSection

    // --- Grimoire Controls ---
    const grimoireRefresh = () => {
         if (!grimoireScreen.classList.contains('hidden')) { // Only refresh if grimoire is visible
             displayGrimoire(grimoireTypeFilter.value, grimoireElementFilter.value, grimoireSortOrder.value, grimoireRarityFilter.value);
         }
    };
    if (grimoireTypeFilter) grimoireTypeFilter.addEventListener('change', grimoireRefresh); else console.error("Grimoire Type filter not found!");
    if (grimoireElementFilter) grimoireElementFilter.addEventListener('change', grimoireRefresh); else console.error("Grimoire Element filter not found!");
    if (grimoireRarityFilter) grimoireRarityFilter.addEventListener('change', grimoireRefresh); else console.error("Grimoire Rarity filter not found!");
    if (grimoireSortOrder) grimoireSortOrder.addEventListener('change', grimoireRefresh); else console.error("Grimoire Sort order not found!");

    // --- Reflection Modal Controls ---
    if (reflectionCheckbox) reflectionCheckbox.addEventListener('change', () => { if(confirmReflectionButton) confirmReflectionButton.disabled = !reflectionCheckbox.checked; }); else console.error("Reflection checkbox not found!");
    if (confirmReflectionButton) confirmReflectionButton.addEventListener('click', handleConfirmReflection); else console.error("Confirm Reflection button not found!");

    // --- Initial Setup ---
    showScreen('welcomeScreen'); // Start on the welcome screen
    console.log("Initial screen set to Welcome.");
}); // End DOMContentLoaded
Use code with caution.
JavaScript
Key Changes and Why:

elementKeyToFullName Re-added: The map const elementKeyToFullName = { A: "Attraction", ... }; was added back near the top of script.js because several functions relied on it.

Detailed Logging in grantEssenceForConcept: Added console.log statements inside this function to track:

When it's called and for which concept.

Which keys it iterates over from the concept's scores.

If a key is valid (exists in elementEssence).

The calculated essenceToGrant.

The updated elementEssence[key] value after addition.

Warnings if scores are invalid or no essence is granted.

Logging for discoveredConcepts: Added console.log statements in determineStarterHandAndEssence after the loop to explicitly show the contents and size of the discoveredConcepts map.

Robustness in determineStarterHandAndEssence: Added checks to ensure concepts is a valid array before processing. Added better error logging in the catch block.

Map Usage Fixes: Corrected functions (synthesizeAndDisplayThemesPersona, renderCard, conductResearch, displayPopupRecipeComparison, displayEvolutionSection, handleConfirmReflection, updateMilestoneProgress) to correctly use elementKeyToFullName or elementNameToKey where appropriate.

UI Refresh Timing: Ensured that UI update functions (displayPersonaScreen, displayGrimoire, displayElementEssenceStudy, etc.) are called in finalizeScoresAndShowPersona after determineStarterHandAndEssence has finished, so they reflect the newly populated data. Also added calls to update essence displays after actions like adding to grimoire, marking core, reflection, etc.

Grimoire Display: Added a call to displayGrimoire() at the end of finalizeScoresAndShowPersona to attempt an initial render. Also modified displayGrimoire to show a more helpful message if empty and removed the showScreen call from within it (navigation handles showing the screen).

Minor Refinements: Improved some console logs and alert messages. Added slight attunement gain even on failed research. Added basic image display for unlocked art (using a placeholder path placeholder_art/). You'll need to create this folder and add .png images named according to your visualHandleUnlocked values.

Next Steps:

Replace your script.js with the code provided above.

Run the application through the questionnaire again.

Carefully examine the console output. Pay close attention to:

The new logs inside [grantEssence]. Do they show essence being calculated and added for each element key for the starter cards?

The log showing [determineStarterHand] Final Initial Essence State:. Does the elementEssence object now have non-zero values?

The log showing [determineStarterHand] Discovered Concepts Map after loop:. Does it list the 7 starter concepts?

Check the UI:

Does the "Elemental Essences" section on the Study screen now show values other than 0.0?

Does the Grimoire screen now show 7 cards when you navigate to it?

Does the Persona Tapestry screen show non-zero essence?

Based on the new console logs, we should be able to pinpoint exactly why essence wasn't being granted and confirm the fix. Let me know what the console shows!

243.0s
Type something

Run
Ctrl
code
Gemini 2.5 Pro Experimental 03-25
1
