// script.js - COMPLETE VERSION v9 (Refined finalizeScores try/catch, includes v8 features)

// --- Global State ---
let currentElementIndex = 0;
let userScores = { A: 5, I: 5, S: 5, P: 5, C: 5, R: 5 }; // Use single letter keys
let userAnswers = {}; // Stores answers keyed by FULL element names during questionnaire
const elementNames = ["Attraction", "Interaction", "Sensory", "Psychological", "Cognitive", "Relational"]; // Full names for display/logic
const cardTypeKeys = ["Orientation", "Identity/Role", "Practice/Kink", "Psychological/Goal", "Relationship Style"]; // For filtering
let currentElementAnswers = {}; // Temp storage for current element's answers
let currentlyDisplayedConceptId = null;
let discoveredConcepts = new Map(); // ID -> { concept, discoveredTime, artUnlocked: boolean }
let focusedConcepts = new Set(); // Track IDs marked as "Focus" (replaces coreConcepts)
let focusSlotsTotal = 5; // Starting number of Focus slots
const MAX_FOCUS_SLOTS = 12; // Absolute maximum focus slots achievable
let userInsight = 10; // Start with some initial Insight
let elementAttunement = { A: 0, I: 0, S: 0, P: 0, C: 0, R: 0 };
const MAX_ATTUNEMENT = 100;
const BASE_RESEARCH_COST = 15; // Base Insight cost for research
const ART_EVOLVE_COST = 20; // Insight cost for art evolution
const DISSONANCE_THRESHOLD = 6.5; // Distance score above which dissonance reflection triggers
const SCORE_NUDGE_AMOUNT = 0.15; // How much score changes on nudge
let freeResearchAvailableToday = false;
let currentReflectionContext = null; // e.g., 'Dissonance', 'Standard'
let reflectionTargetConceptId = null; // Stores concept ID for dissonance reflection actions
let seenPrompts = new Set();
let completedRituals = { daily: {}, weekly: {} }; // Track by ID: { completed: boolean, progress: number }
let achievedMilestones = new Set();
let lastLoginDate = null;
let cardsAddedSinceLastPrompt = 0;
let promptCooldownActive = false;
let currentReflectionElement = null; // Store the FULL NAME of the element for reflection
let currentPromptId = null; // Store the ID of the prompt shown

// --- DOM Elements ---
// (Ensure these IDs match your index.html v8)
const screens = document.querySelectorAll('.screen');
const startButton = document.getElementById('startGuidedButton');
const questionnaireScreen = document.getElementById('questionnaireScreen');
const elementProgressHeader = document.getElementById('elementProgressHeader');
const questionContent = document.getElementById('questionContent');
const progressText = document.getElementById('progressText');
const dynamicScoreFeedback = document.getElementById('dynamicScoreFeedback');
const feedbackElementSpan = document.getElementById('feedbackElement');
const feedbackScoreSpan = document.getElementById('feedbackScore');
const feedbackScoreBar = document.getElementById('feedbackScoreBar');
const prevElementButton = document.getElementById('prevElementButton');
const nextElementButton = document.getElementById('nextElementButton');
const mainNavBar = document.getElementById('mainNavBar');
const navButtons = document.querySelectorAll('.nav-button');
const personaScreen = document.getElementById('personaScreen');
const personaElementDetailsDiv = document.getElementById('personaElementDetails');
const userInsightDisplayPersona = document.getElementById('userInsightDisplayPersona');
const focusedConceptsDisplay = document.getElementById('focusedConceptsDisplay');
const focusedConceptsHeader = document.getElementById('focusedConceptsHeader');
const personaThemesList = document.getElementById('personaThemesList');
const restartButtonPersona = document.getElementById('restartButtonPersona');
const studyScreen = document.getElementById('studyScreen');
const userInsightDisplayStudy = document.getElementById('userInsightDisplayStudy');
const researchButtonContainer = document.getElementById('researchButtonContainer');
const freeResearchButton = document.getElementById('freeResearchButton');
const researchStatus = document.getElementById('researchStatus');
const grimoireScreen = document.getElementById('grimoireScreen');
const grimoireCountSpan = document.getElementById('grimoireCount');
const grimoireTypeFilter = document.getElementById('grimoireTypeFilter');
const grimoireElementFilter = document.getElementById('grimoireElementFilter');
const grimoireRarityFilter = document.getElementById('grimoireRarityFilter');
const grimoireSortOrder = document.getElementById('grimoireSortOrder');
const grimoireContentDiv = document.getElementById('grimoireContent');
const conceptDetailPopup = document.getElementById('conceptDetailPopup');
const popupOverlay = document.getElementById('popupOverlay');
const popupCardTypeIcon = document.getElementById('popupCardTypeIcon');
const popupConceptName = document.getElementById('popupConceptName');
const popupConceptType = document.getElementById('popupConceptType');
const popupVisualContainer = document.getElementById('popupVisualContainer');
const popupDetailedDescription = document.getElementById('popupDetailedDescription');
const popupResonanceSummary = document.getElementById('popupResonanceSummary');
const popupComparisonHighlights = document.getElementById('popupComparisonHighlights');
const popupConceptProfile = document.getElementById('popupConceptProfile');
const popupUserComparisonProfile = document.getElementById('popupUserComparisonProfile');
const popupRelatedConceptsList = document.getElementById('relatedConceptsList');
const closePopupButton = document.getElementById('closePopupButton');
const addToGrimoireButton = document.getElementById('addToGrimoireButton');
const markAsFocusButton = document.getElementById('markAsFocusButton');
const researchModal = document.getElementById('researchModal');
const researchModalContent = document.getElementById('researchModalContent');
const researchModalStatus = document.getElementById('researchModalStatus');
const closeResearchModalButton = document.getElementById('closeResearchModalButton');
const elementAttunementDisplay = document.getElementById('elementAttunementDisplay');
const dailyRitualsDisplay = document.getElementById('dailyRitualsDisplay');
const milestonesDisplay = document.getElementById('milestonesDisplay');
const popupEvolutionSection = document.getElementById('popupEvolutionSection');
const evolveArtButton = document.getElementById('evolveArtButton');
const evolveCostSpan = document.getElementById('evolveCost');
const evolveEligibility = document.getElementById('evolveEligibility');
const reflectionModal = document.getElementById('reflectionModal');
const closeReflectionModalButton = document.getElementById('closeReflectionModalButton');
const reflectionElement = document.getElementById('reflectionElement');
const reflectionPromptText = document.getElementById('reflectionPromptText');
const reflectionCheckbox = document.getElementById('reflectionCheckbox');
const scoreNudgeCheckbox = document.getElementById('scoreNudgeCheckbox');
const scoreNudgeLabel = document.getElementById('scoreNudgeLabel');
const confirmReflectionButton = document.getElementById('confirmReflectionButton');
const reflectionRewardAmount = document.getElementById('reflectionRewardAmount');
const milestoneAlert = document.getElementById('milestoneAlert');
const milestoneAlertText = document.getElementById('milestoneAlertText');
const closeMilestoneAlertButton = document.getElementById('closeMilestoneAlertButton');


// --- Utility & Setup Functions ---
function gainInsight(amount, source = "Unknown") { if (typeof amount !== 'number' || isNaN(amount) || amount <= 0) return; userInsight += amount; console.log(`Gained ${amount.toFixed(1)} Insight from ${source}. New total: ${userInsight.toFixed(1)}`); updateInsightDisplays(); }
function updateInsightDisplays() { const formattedInsight = userInsight.toFixed(1); if (userInsightDisplayPersona) userInsightDisplayPersona.textContent = formattedInsight; if (userInsightDisplayStudy) userInsightDisplayStudy.textContent = formattedInsight; displayResearchButtons(); }
function getScoreLabel(score) { if (typeof score !== 'number' || isNaN(score)) return "N/A"; if (score >= 9) return "Very High"; if (score >= 7) return "High"; if (score >= 5) return "Moderate"; if (score >= 3) return "Low"; return "Very Low"; }
function getAffinityLevel(score) { if (typeof score !== 'number' || isNaN(score)) return null; if (score >= 8) return "High"; if (score >= 5) return "Moderate"; return null; }
function getElementColor(elementName) { const colors = { Attraction: '#FF6347', Interaction: '#4682B4', Sensory: '#32CD32', Psychological: '#FFD700', Cognitive: '#8A2BE2', Relational: '#FF8C00' }; return colors[elementName] || '#CCCCCC'; }
function hexToRgba(hex, alpha = 1) { if (!hex || typeof hex !== 'string') return `rgba(128,128,128, ${alpha})`; hex = hex.replace('#', ''); if (hex.length === 3) hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2]; const bigint = parseInt(hex, 16); if (isNaN(bigint)) return `rgba(128,128,128, ${alpha})`; const r = (bigint >> 16) & 255; const g = (bigint >> 8) & 255; const b = bigint & 255; return `rgba(${r},${g},${b},${alpha})`; }
function getCardTypeIcon(cardType) { switch (cardType) { case "Orientation": return "fa-solid fa-compass"; case "Identity/Role": return "fa-solid fa-mask"; case "Practice/Kink": return "fa-solid fa-gear"; case "Psychological/Goal": return "fa-solid fa-brain"; case "Relationship Style": return "fa-solid fa-heart"; default: return "fa-solid fa-question-circle"; } }
function getElementIcon(elementName) { switch (elementName) { case "Attraction": return "fa-solid fa-magnet"; case "Interaction": return "fa-solid fa-users"; case "Sensory": return "fa-solid fa-hand-sparkles"; case "Psychological": return "fa-solid fa-comment-dots"; case "Cognitive": return "fa-solid fa-lightbulb"; case "Relational": return "fa-solid fa-link"; default: return "fa-solid fa-atom"; } }
const elementNameToKey = { "Attraction": "A", "Interaction": "I", "Sensory": "S", "Psychological": "P", "Cognitive": "C", "Relational": "R" };
// elementKeyToFullName comes from data.js

function euclideanDistance(userScoresObj, conceptScoresObj) { let sumOfSquares = 0; let validDimensions = 0; let issueFound = false; if (!userScoresObj || typeof userScoresObj !== 'object') { console.error("Invalid user scores:", userScoresObj); return Infinity; } if (!conceptScoresObj || typeof conceptScoresObj !== 'object') { console.warn(`Invalid concept scores object for ID ${conceptScoresObj?.id || '?'}`); return Infinity; } const expectedKeys = Object.keys(userScoresObj); const expectedDimensions = expectedKeys.length; if (expectedDimensions === 0) { console.warn("User scores object is empty."); return Infinity; } for (const key of expectedKeys) { const s1 = userScoresObj[key]; const s2 = conceptScoresObj[key]; const s1Valid = typeof s1 === 'number' && !isNaN(s1); const s2Valid = conceptScoresObj.hasOwnProperty(key) && typeof s2 === 'number' && !isNaN(s2); if (s1Valid && s2Valid) { sumOfSquares += Math.pow(s1 - s2, 2); validDimensions++; } else { if (!s2Valid) { console.warn(`Invalid/Missing CONCEPT score for key ${key}. Concept ID: ${conceptScoresObj.id || '?'}`); } issueFound = true; } } if (validDimensions !== expectedDimensions) { console.warn(`Dimension mismatch or invalid data. Expected ${expectedDimensions}, got ${validDimensions} valid. Concept ID: ${conceptScoresObj.id || '?'}`, userScoresObj, conceptScoresObj); issueFound = true; } return !issueFound ? Math.sqrt(sumOfSquares) : Infinity; }

// --- Screen Management ---
function showScreen(screenId) { console.log("Showing screen:", screenId); let targetIsMain = ['personaScreen', 'studyScreen', 'grimoireScreen'].includes(screenId); screens.forEach(screen => { screen.classList.toggle('current', screen.id === screenId); screen.classList.toggle('hidden', screen.id !== screenId); }); if (mainNavBar) mainNavBar.classList.toggle('hidden', !targetIsMain); else console.warn("mainNavBar not found"); navButtons.forEach(button => { button.classList.toggle('active', button.dataset.target === screenId); }); if (['questionnaireScreen', 'grimoireScreen', 'personaScreen', 'studyScreen'].includes(screenId)) { window.scrollTo(0, 0); } }
function hidePopups() { if (conceptDetailPopup) conceptDetailPopup.classList.add('hidden'); if (researchModal) researchModal.classList.add('hidden'); if (reflectionModal) reflectionModal.classList.add('hidden'); if (popupOverlay) popupOverlay.classList.add('hidden'); currentlyDisplayedConceptId = null; currentReflectionElement = null; currentPromptId = null; currentReflectionContext = null; reflectionTargetConceptId = null; }

// --- Initialization and Questionnaire Logic ---
function initializeQuestionnaire() { console.log("[initializeQuestionnaire] Function Started."); currentElementIndex = 0; userScores = { A: 5, I: 5, S: 5, P: 5, C: 5, R: 5 }; userAnswers = {}; elementNames.forEach(elName => { userAnswers[elName] = {}; }); discoveredConcepts = new Map(); focusedConcepts = new Set(); userInsight = 10; focusSlotsTotal = 5; elementAttunement = { A: 0, I: 0, S: 0, P: 0, C: 0, R: 0 }; seenPrompts = new Set(); completedRituals = { daily: {}, weekly: {} }; achievedMilestones = new Set(); lastLoginDate = null; cardsAddedSinceLastPrompt = 0; promptCooldownActive = false; freeResearchAvailableToday = false; updateElementProgressHeader(-1); displayElementQuestions(currentElementIndex); showScreen('questionnaireScreen'); if (mainNavBar) mainNavBar.classList.add('hidden'); if(dailyRitualsDisplay) dailyRitualsDisplay.innerHTML = '<li>Loading...</li>'; if(milestonesDisplay) milestonesDisplay.innerHTML = '<li>None yet</li>'; if(elementAttunementDisplay) elementAttunementDisplay.innerHTML = ''; if(grimoireContentDiv) grimoireContentDiv.innerHTML = '<p>Grimoire empty.</p>'; if(focusedConceptsDisplay) focusedConceptsDisplay.innerHTML = '<li>Mark concepts as "Focus"...</li>'; updateInsightDisplays(); updateFocusSlotsDisplay(); updateGrimoireCounter(); if(researchButtonContainer) researchButtonContainer.innerHTML = ''; if(freeResearchButton) freeResearchButton.classList.add('hidden'); }
function updateElementProgressHeader(activeIndex) { if (!elementProgressHeader) return; elementProgressHeader.innerHTML = ''; elementNames.forEach((name, index) => { const tab = document.createElement('div'); tab.classList.add('element-tab'); const elementData = elementDetails[name] || {}; tab.textContent = elementData.name || name; tab.title = elementData.name || name; tab.classList.toggle('completed', index < activeIndex); tab.classList.toggle('active', index === activeIndex); elementProgressHeader.appendChild(tab); }); }
function displayElementQuestions(index) { if (index >= elementNames.length) { finalizeScoresAndShowPersona(); return; } const elementName = elementNames[index]; const elementData = elementDetails[elementName] || {}; const questions = questionnaireGuided[elementName] || []; const questionContentElement = document.getElementById('questionContent'); if (!questionContentElement) { console.error("!!! questionContent element not found !!!"); return; } let introHTML = `<div class="element-intro"><h2>${elementData.name || elementName}</h2><p><em>${elementData.coreQuestion || ''}</em></p><p>${elementData.coreConcept || 'Loading...'}</p><p><small><strong>Persona Connection:</strong> ${elementData.personaConnection || ''}</small></p></div>`; questionContentElement.innerHTML = introHTML; currentElementAnswers = { ...(userAnswers[elementName] || {}) }; let questionsHTML = ''; if (questions && questions.length > 0) { questions.forEach(q => { let inputHTML = `<div class="question-block" id="block_${q.qId}"><h3 class="question-title">${q.text}</h3><div class="input-container">`; const savedAnswer = currentElementAnswers[q.qId]; if (q.type === "slider") { const val = savedAnswer !== undefined ? savedAnswer : q.defaultValue; inputHTML += ` <div class="slider-container"> <input type="range" id="${q.qId}" class="slider q-input" min="${q.minValue}" max="${q.maxValue}" step="${q.step || 0.5}" value="${val}" data-question-id="${q.qId}" data-type="slider"> <div class="label-container"> <span class="label-text">${q.minLabel}</span><span class="label-text">${q.maxLabel}</span> </div> <p class="value-text">Selected: <span id="display_${q.qId}">${parseFloat(val).toFixed(1)}</span></p> <p class="slider-feedback" id="feedback_${q.qId}"></p> </div>`; } else if (q.type === "radio") { inputHTML += `<div class="radio-options">`; q.options.forEach(opt => { const checked = savedAnswer === opt.value ? 'checked' : ''; inputHTML += `<div><input type="radio" id="${q.qId}_${opt.value}" class="q-input" name="${q.qId}" value="${opt.value}" ${checked} data-question-id="${q.qId}" data-type="radio"><label for="${q.qId}_${opt.value}">${opt.value}</label></div>`; }); inputHTML += `</div>`; } else if (q.type === "checkbox") { inputHTML += `<div class="checkbox-options">`; q.options.forEach(opt => { const checked = savedAnswer?.includes(opt.value) ? 'checked' : ''; inputHTML += `<div><input type="checkbox" id="${q.qId}_${opt.value}" class="q-input" name="${q.qId}" value="${opt.value}" ${checked} data-question-id="${q.qId}" data-max-choices="${q.maxChoices || 2}" data-type="checkbox"><label for="${q.qId}_${opt.value}">${opt.value}</label></div>`; }); inputHTML += `</div>`; } inputHTML += `</div></div>`; questionsHTML += inputHTML; }); } else { console.warn(`[displayElementQuestions] No questions found for element: ${elementName}`); questionsHTML = '<p><em>(No questions defined)</em></p>'; } const introDiv = questionContentElement.querySelector('.element-intro'); if (introDiv) { introDiv.insertAdjacentHTML('afterend', questionsHTML); } else { questionContentElement.innerHTML += questionsHTML; } questionContentElement.querySelectorAll('.q-input').forEach(input => { const eventType = (input.type === 'range') ? 'input' : 'change'; input.addEventListener(eventType, handleQuestionnaireInputChange); }); questionContentElement.querySelectorAll('input[type="checkbox"].q-input').forEach(checkbox => { checkbox.addEventListener('change', (event) => enforceMaxChoices(checkbox.name, parseInt(checkbox.dataset.maxChoices || 2), event)); }); questionContentElement.querySelectorAll('.slider.q-input').forEach(slider => { updateSliderFeedbackText(slider); }); updateElementProgressHeader(index); if (progressText) progressText.textContent = `Element ${index + 1} / ${elementNames.length}: ${elementData.name || elementName}`; updateDynamicFeedback(elementName); if (dynamicScoreFeedback) dynamicScoreFeedback.style.display = 'block'; if (prevElementButton) prevElementButton.style.visibility = (index > 0) ? 'visible' : 'hidden'; if (nextElementButton) nextElementButton.textContent = (index === elementNames.length - 1) ? "View My Persona" : "Next Element"; }
function updateSliderFeedbackText(sliderElement) { if (!sliderElement || sliderElement.type !== 'range') return; const qId = sliderElement.dataset.questionId; const feedbackElement = document.getElementById(`feedback_${qId}`); if (!feedbackElement) return; const currentValue = parseFloat(sliderElement.value); const elementName = elementNames[currentElementIndex]; const interpretations = elementDetails?.[elementName]?.scoreInterpretations; if (!interpretations) { console.warn(`Interpretations not found for element: ${elementName}`); feedbackElement.textContent = `(Score: ${currentValue.toFixed(1)})`; return; } const scoreLabel = getScoreLabel(currentValue); const interpretationText = interpretations[scoreLabel] || `Interpretation for "${scoreLabel}" not found.`; feedbackElement.textContent = interpretationText; feedbackElement.title = `Meaning of score ${currentValue.toFixed(1)} (${scoreLabel})`; }
function handleQuestionnaireInputChange(event) { const input = event.target; const type = input.dataset.type; const elementName = elementNames[currentElementIndex]; if (type === 'slider') { const qId = input.dataset.questionId; const display = document.getElementById(`display_${qId}`); if (display) display.textContent = parseFloat(input.value).toFixed(1); updateSliderFeedbackText(input); } collectCurrentElementAnswers(); updateDynamicFeedback(elementName); }
function enforceMaxChoices(name, max, event) { const checkboxes = questionContent?.querySelectorAll(`input[name="${name}"]:checked`); if (!checkboxes) return; if (checkboxes.length > max) { alert(`Max ${max} options.`); if (event?.target?.checked) { event.target.checked = false; collectCurrentElementAnswers(); updateDynamicFeedback(elementNames[currentElementIndex]); } } }
function collectCurrentElementAnswers() { const elementName = elementNames[currentElementIndex]; const questions = questionnaireGuided[elementName] || []; currentElementAnswers = {}; questions.forEach(q => { const qId = q.qId; const container = questionContent || document; if (q.type === 'slider') { const input = container.querySelector(`#${qId}.q-input`); if (input) currentElementAnswers[qId] = parseFloat(input.value); } else if (q.type === 'radio') { const checked = container.querySelector(`input[name="${qId}"]:checked`); if (checked) currentElementAnswers[qId] = checked.value; } else if (q.type === 'checkbox') { const checked = container.querySelectorAll(`input[name="${qId}"]:checked`); currentElementAnswers[qId] = Array.from(checked).map(cb => cb.value); } }); userAnswers[elementName] = { ...currentElementAnswers }; }
function updateDynamicFeedback(elementName) { const elementData = elementDetails?.[elementName]; if (!elementData) { console.warn(`Element details not found: ${elementName}`); return; } if (!dynamicScoreFeedback || !feedbackElementSpan || !feedbackScoreSpan || !feedbackScoreBar) { console.warn("Dyn feedback DOM missing."); return; } const tempScore = calculateElementScore(elementName, currentElementAnswers); const scoreLabel = getScoreLabel(tempScore); feedbackElementSpan.textContent = elementData.name || elementName; feedbackScoreSpan.textContent = tempScore.toFixed(1); let labelSpan = dynamicScoreFeedback.querySelector('.score-label'); if (!labelSpan) { labelSpan = document.createElement('span'); labelSpan.classList.add('score-label'); feedbackScoreSpan.parentNode.insertBefore(document.createTextNode(' '), feedbackScoreSpan.nextSibling); feedbackScoreSpan.parentNode.insertBefore(labelSpan, feedbackScoreSpan.nextSibling.nextSibling); } labelSpan.textContent = `(${scoreLabel})`; feedbackScoreBar.style.width = `${tempScore * 10}%`; let interpretationP = dynamicScoreFeedback.querySelector('.interpretation-text'); if (interpretationP) { interpretationP.remove(); } }
function calculateElementScore(elementName, answersForElement) { const questions = questionnaireGuided[elementName] || []; let score = 5.0; questions.forEach(q => { const answer = answersForElement[q.qId]; let pointsToAdd = 0; if (q.type === 'slider') { const value = (answer !== undefined) ? answer : q.defaultValue; pointsToAdd = (value - q.defaultValue) * (q.scoreWeight || 1.0); } else if (q.type === 'radio') { const opt = q.options.find(o => o.value === answer); pointsToAdd = opt ? (opt.points || 0) * (q.scoreWeight || 1.0) : 0; } else if (q.type === 'checkbox' && Array.isArray(answer)) { answer.forEach(val => { const opt = q.options.find(o => o.value === val); pointsToAdd += opt ? (opt.points || 0) * (q.scoreWeight || 1.0) : 0; }); } score += pointsToAdd; }); return Math.max(0, Math.min(10, score)); }
function nextElement() { collectCurrentElementAnswers(); currentElementIndex++; displayElementQuestions(currentElementIndex); }
function prevElement() { collectCurrentElementAnswers(); currentElementIndex--; displayElementQuestions(currentElementIndex); }

// *** UPDATED finalize function with refined try/catch ***
function finalizeScoresAndShowPersona() {
     console.log("Finalizing scores...");
     const finalScores = {};
     try {
         elementNames.forEach(elementName => {
             const score = calculateElementScore(elementName, userAnswers[elementName] || {});
             const key = elementNameToKey[elementName];
             if (key) { finalScores[key] = score; }
             else { console.warn(`Could not find key for element name: ${elementName}`); }
         });

         userScores = finalScores;
         console.log("Final User Scores:", userScores);

         // --- Sequence of actions after scoring ---
         determineStarterHandAndEssence(); // Grants attunement, adds to discovered
         updateMilestoneProgress('completeQuestionnaire', 1);
         checkForDailyLogin(); // Resets daily rituals, grants free research
         displayPersonaScreen(); // Displays scores, attunement, insight, focus slots
         displayStudyScreenContent(); // Displays insight, research buttons
         displayDailyRituals();
         displayMilestones();
         populateGrimoireFilters();
         updateGrimoireCounter(); // Update based on starter hand
         displayGrimoire(); // Render starter hand in grimoire view
         showScreen('personaScreen'); // Show persona screen first
         setTimeout(() => { alert("Experiment Complete! Explore your Persona Tapestry, Grimoire, and The Study."); }, 100);
         // --- End sequence ---

     } catch (error) {
         console.error("Error during finalizeScoresAndShowPersona sequence:", error);
         try {
             showScreen('welcomeScreen');
             alert("An error occurred during setup. Please check the console (F12) and try restarting.");
         } catch (fallbackError) {
             console.error("Error during fallback sequence:", fallbackError);
             document.body.innerHTML = "<h1>Critical Error</h1><p>Setup failed. Check console (F12) and refresh.</p>";
         }
     }
}


// --- Starter Hand & Resource Granting ---
function determineStarterHandAndEssence() { console.log("[determineStarterHand] Function called."); console.log("[determineStarterHand] Checking 'concepts' variable type:", typeof concepts, "Is Array:", Array.isArray(concepts), "Length:", concepts?.length); console.log("[determineStarterHand] Checking 'elementKeyToFullName' variable type:", typeof elementKeyToFullName); try { discoveredConcepts = new Map(); console.log("[determineStarterHand] State reset (excluding Insight)."); if (!concepts || !Array.isArray(concepts) || concepts.length === 0) { console.error("[determineStarterHand] 'concepts' array is missing!"); return; } if (typeof elementKeyToFullName === 'undefined' || elementKeyToFullName === null) { console.error("[determineStarterHand] 'elementKeyToFullName' map is missing!"); return; } let conceptsWithDistance = []; console.log(`[determineStarterHand] Processing ${concepts.length} total concepts.`); concepts.forEach((c, index) => { if (!c || typeof c !== 'object' || !c.id || !c.elementScores) { console.warn(`[determineStarterHand] Skipping invalid concept at index ${index}:`, c); return; } const conceptScores = c.elementScores; const distance = euclideanDistance(userScores, conceptScores); if (index < 5) { console.log(`[determineStarterHand] Dist calc for ID ${c.id} (${c.name}): ${distance}`); } if (distance !== Infinity && typeof distance === 'number' && !isNaN(distance)) { conceptsWithDistance.push({ ...c, distance: distance }); } else { console.warn(`[determineStarterHand] Skipping concept ${c.id} (${c.name}) due to invalid distance: ${distance}`); } }); console.log(`[determineStarterHand] Found ${conceptsWithDistance.length} concepts with valid distances.`); if (conceptsWithDistance.length === 0) { console.error("[determineStarterHand] No concepts comparable!"); return; } conceptsWithDistance.sort((a, b) => a.distance - b.distance); console.log("[determineStarterHand] Concepts sorted (Top 15):", conceptsWithDistance.slice(0,15).map(c => `${c.name}(${c.distance.toFixed(1)})`)); const candidates = conceptsWithDistance.slice(0, 15); const starterHand = []; const representedElements = new Set(); const starterHandIds = new Set(); for (const c of candidates) { if (starterHand.length >= 4) break; if (!starterHandIds.has(c.id)) { starterHand.push(c); starterHandIds.add(c.id); if (c.primaryElement) representedElements.add(c.primaryElement); } } for (const c of candidates) { if (starterHand.length >= 7) break; if (starterHandIds.has(c.id)) continue; const isRepresented = c.primaryElement && representedElements.has(c.primaryElement); const forceAdd = candidates.slice(candidates.indexOf(c)).every(remaining => (remaining.primaryElement && representedElements.has(remaining.primaryElement)) || starterHand.length >= 7 ); if (!isRepresented || forceAdd) { starterHand.push(c); starterHandIds.add(c.id); if (c.primaryElement) representedElements.add(c.primaryElement); } } for (const c of candidates) { if (starterHand.length >= 7) break; if (!starterHandIds.has(c.id)) { starterHand.push(c); starterHandIds.add(c.id); } } console.log("[determineStarterHand] Starter Hand Selected:", starterHand.map(c => c.name)); if (starterHand.length === 0) { console.error("[determineStarterHand] Failed to select starter hand!"); return; } starterHand.forEach(concept => { console.log(`[determineStarterHand] Processing starter card: ${concept.name} (ID: ${concept.id})`); discoveredConcepts.set(concept.id, { concept: concept, discoveredTime: Date.now(), artUnlocked: false }); gainAttunementForAction('discover', concept.primaryElement); }); console.log("[determineStarterHand] Discovered Concepts Map after loop:", discoveredConcepts); console.log(`[determineStarterHand] Discovered Concepts Count: ${discoveredConcepts.size}`); } catch (error) { console.error("!!! UNCAUGHT ERROR in determineStarterHand !!!", error); } console.log("[determineStarterHand] Function finished."); }

// --- Attunement ---
function gainAttunementForAction(actionType, elementKey = null, amount = 0.5) { let targetKeys = []; const gainAmount = amount; if (elementKey && elementAttunement.hasOwnProperty(elementKey)) { targetKeys.push(elementKey); } else if (actionType === 'completeReflection' && currentReflectionElement) { const key = elementNameToKey[currentReflectionElement]; if (key && elementAttunement.hasOwnProperty(key)) { targetKeys.push(key); } else { console.warn(`Could not find key for reflection element: ${currentReflectionElement}`); } } else if (actionType === 'generic' || elementKey === 'All' || actionType === 'completeReflectionGeneric' || actionType === 'scoreNudge') { targetKeys = Object.keys(elementAttunement); amount = actionType === 'generic' ? 0.1 : (actionType === 'completeReflectionGeneric' ? 0.2 : amount); } else { return; } let changed = false; targetKeys.forEach(key => { const currentAttunement = elementAttunement[key] || 0; const newAttunement = Math.min(MAX_ATTUNEMENT, currentAttunement + gainAmount); if (newAttunement > currentAttunement) { elementAttunement[key] = newAttunement; changed = true; } }); if (changed) { const displayKey = elementKey || 'Multi/None'; let logMessage = `Attunement updated (${actionType}, Key: ${displayKey}`; if (typeof elementKeyToFullName !== 'undefined' && elementKeyToFullName?.[elementKey]) { logMessage += ` - ${elementKeyToFullName[elementKey]}`; } console.log(logMessage + '):', elementAttunement); displayElementAttunement(); } }
function displayElementAttunement() { if (!elementAttunementDisplay) return; elementAttunementDisplay.innerHTML = ''; elementNames.forEach(elName => { const key = elementNameToKey[elName]; const attunementValue = elementAttunement[key] || 0; const percentage = (attunementValue / MAX_ATTUNEMENT) * 100; elementAttunementDisplay.innerHTML += `<div class="attunement-item"><span class="attunement-name">${elementDetails[elName]?.name || elName}:</span><div class="attunement-bar-container" title="${attunementValue.toFixed(1)} / ${MAX_ATTUNEMENT}"><div class="attunement-bar" style="width: ${percentage}%; background-color: ${getElementColor(elName)};"></div></div></div>`; }); }

// --- Persona Screen Functions ---
function updateFocusSlotsDisplay() { if (focusedConceptsHeader) { focusedConceptsHeader.textContent = `Focused Concepts (${focusedConcepts.size} / ${focusSlotsTotal})`; } }
function displayPersonaScreen() { if (!personaElementDetailsDiv) { console.error("Persona details div not found!"); return; } personaElementDetailsDiv.innerHTML = ''; elementNames.forEach(elementName => { const key = elementNameToKey[elementName]; const score = userScores[key]; const scoreLabel = getScoreLabel(score); const elementData = elementDetails[elementName] || {}; const interpretation = elementData.scoreInterpretations?.[scoreLabel] || "N/A"; const barWidth = score ? (score / 10) * 100 : 0; const color = getElementColor(elementName); const details = document.createElement('details'); details.classList.add('element-detail-entry'); details.style.setProperty('--element-color', color); details.innerHTML = `<summary class="element-detail-header"><div><strong>${elementData.name || elementName}:</strong><span>${score?.toFixed(1) ?? '?'}</span> <span class="score-label">(${scoreLabel})</span></div><div class="score-bar-container"><div style="width: ${barWidth}%; background-color: ${color};"></div></div></summary><div class="element-description"><p><strong>Core Concept:</strong> ${elementData.coreConcept || ''}</p><p><strong>Elaboration:</strong> ${elementData.elaboration || ''}</p><hr><p><strong>Your Score (${scoreLabel}):</strong> ${interpretation}</p><p><small><strong>Examples:</strong> ${elementData.examples || ''}</small></p></div>`; personaElementDetailsDiv.appendChild(details); }); updateInsightDisplays(); displayElementAttunement(); displayFocusedConceptsPersona(); synthesizeAndDisplayThemesPersona(); displayMilestones(); }
function displayFocusedConceptsPersona() { if (!focusedConceptsDisplay) return; focusedConceptsDisplay.innerHTML = ''; updateFocusSlotsDisplay(); if (focusedConcepts.size === 0) { focusedConceptsDisplay.innerHTML = `<li>Mark concepts as "Focus" to weave your active Tapestry (Max ${focusSlotsTotal}).</li>`; return; } focusedConcepts.forEach(conceptId => { const conceptData = discoveredConcepts.get(conceptId); if (conceptData?.concept) { const concept = conceptData.concept; const item = document.createElement('div'); item.classList.add('focus-concept-item'); item.dataset.conceptId = concept.id; item.title = `View ${concept.name}`; item.innerHTML = `<i class="${getCardTypeIcon(concept.cardType)}"></i><span class="name">${concept.name}</span><span class="type">(${concept.cardType})</span>`; item.addEventListener('click', () => showConceptDetailPopup(concept.id)); focusedConceptsDisplay.appendChild(item); } else { console.warn(`Focused concept ID ${conceptId} not found in discoveredConcepts.`); } }); }
function synthesizeAndDisplayThemesPersona() { if (!personaThemesList) return; personaThemesList.innerHTML = ''; if (focusedConcepts.size === 0) { personaThemesList.innerHTML = '<li>Mark Focused Concepts for themes.</li>'; return; } if (typeof elementKeyToFullName === 'undefined') { console.error("synthesizeThemes: map missing!"); return; } const elementCountsByKey = { A: 0, I: 0, S: 0, P: 0, C: 0, R: 0 }; const threshold = 7.0; focusedConcepts.forEach(id => { const discoveredData = discoveredConcepts.get(id); const concept = discoveredData?.concept; if (concept?.elementScores) { for (const key in concept.elementScores) { if (elementKeyToFullName.hasOwnProperty(key) && concept.elementScores[key] >= threshold) { elementCountsByKey[key]++; } } } }); const sortedThemes = Object.entries(elementCountsByKey) .filter(([key, count]) => count > 0 && elementKeyToFullName[key]) .sort(([, a], [, b]) => b - a) .map(([key, count]) => ({ name: elementDetails[elementKeyToFullName[key]]?.name || key, count })); if (sortedThemes.length === 0) { personaThemesList.innerHTML = '<li>No strong themes (score >= 7.0) detected in Focused Concepts.</li>'; return; } sortedThemes.slice(0, 3).forEach(theme => { const li = document.createElement('li'); li.textContent = `${theme.name} Focus (${theme.count} Focused concepts)`; personaThemesList.appendChild(li); }); }

// --- Study Screen Functions ---
function displayStudyScreenContent() { updateInsightDisplays(); displayResearchButtons(); displayDailyRituals(); }
function displayResearchButtons() { if (!researchButtonContainer) return; researchButtonContainer.innerHTML = ''; if (freeResearchAvailableToday && freeResearchButton) { freeResearchButton.classList.remove('hidden'); freeResearchButton.disabled = false; freeResearchButton.textContent = "Perform Daily Meditation (Free Research)"; freeResearchButton.onclick = handleFreeResearchClick; } else if (freeResearchButton) { freeResearchButton.classList.add('hidden'); } elementNames.forEach(elName => { const key = elementNameToKey[elName]; const currentAttunement = elementAttunement[key] || 0; let currentCost = BASE_RESEARCH_COST; if (currentAttunement > 80) currentCost = Math.max(1, BASE_RESEARCH_COST - 5); else if (currentAttunement > 50) currentCost = Math.max(1, BASE_RESEARCH_COST - 3); const canAfford = userInsight >= currentCost; const fullName = elementDetails[elName]?.name || elName; const button = document.createElement('button'); button.classList.add('button', 'research-button'); button.dataset.elementKey = key; button.dataset.cost = currentCost; button.disabled = !canAfford; button.title = `Focus on ${fullName} (Cost: ${currentCost} Insight)`; button.innerHTML = ` <span class="research-el-icon" style="color: ${getElementColor(elName)};"><i class="${getElementIcon(fullName)}"></i></span> <span class="research-el-name">${fullName}</span> <span class="research-el-cost">${currentCost} <i class="fas fa-brain insight-icon"></i></span> `; button.addEventListener('click', handleResearchClick); researchButtonContainer.appendChild(button); }); }
function handleResearchClick(event) { const button = event.currentTarget; const elementKey = button.dataset.elementKey; const currentCost = parseFloat(button.dataset.cost); if (!elementKey || isNaN(currentCost) || button.disabled) return; if (userInsight >= currentCost) { userInsight -= currentCost; updateInsightDisplays(); console.log(`Spent ${currentCost} Insight researching ${elementKey}.`); conductResearch(elementKey); updateMilestoneProgress('conductResearch', 1); checkAndUpdateRituals('conductResearch'); } else { alert(`Not enough Insight! Need ${currentCost}.`); } }
function handleFreeResearchClick() { if (!freeResearchAvailableToday) { alert("Daily meditation already performed."); return; } const keys = Object.keys(elementAttunement); let targetKey = keys[0]; let minAttunement = MAX_ATTUNEMENT + 1; keys.forEach(key => { if (elementAttunement[key] < minAttunement) { minAttunement = elementAttunement[key]; targetKey = key; } }); console.log(`Performing free daily meditation on ${targetKey}`); freeResearchAvailableToday = false; if (freeResearchButton) { freeResearchButton.disabled = true; freeResearchButton.textContent = "Daily Meditation Performed"; } conductResearch(targetKey); updateMilestoneProgress('freeResearch', 1); checkAndUpdateRituals('freeResearch'); }
function conductResearch(elementKeyToResearch) { if (typeof elementKeyToFullName === 'undefined') { console.error("conductResearch: map missing!"); return; } const elementFullName = elementKeyToFullName[elementKeyToResearch]; if (!elementFullName) { console.error("Invalid key for research:", elementKeyToResearch); return; } console.log(`Researching: ${elementFullName} (Key: ${elementKeyToResearch})`); if (researchStatus) researchStatus.textContent = `Focusing on ${elementDetails[elementFullName]?.name || elementFullName}...`; if (researchModalContent) researchModalContent.innerHTML = ''; const discoveredIds = new Set(discoveredConcepts.keys()); const undiscoveredPool = concepts.filter(c => !discoveredIds.has(c.id)); if (undiscoveredPool.length === 0) { if (researchModalStatus) researchModalStatus.textContent = "All concepts discovered!"; if (researchStatus) researchStatus.textContent = "Research complete. No more concepts."; if (researchModal) researchModal.classList.remove('hidden'); if (popupOverlay) popupOverlay.classList.remove('hidden'); return; } const currentAttunement = elementAttunement[elementKeyToResearch] || 0; const priorityPool = []; const secondaryPool = []; const tertiaryPool = [...undiscoveredPool]; undiscoveredPool.forEach(c => { const score = c.elementScores?.[elementKeyToResearch] || 0; const primary = c.primaryElement === elementKeyToResearch; const indexInTertiary = tertiaryPool.findIndex(tc => tc.id === c.id); if (primary || score >= 8.0) { priorityPool.push(c); if (indexInTertiary > -1) tertiaryPool.splice(indexInTertiary, 1); } else if (score >= 5.0) { secondaryPool.push(c); if (indexInTertiary > -1) tertiaryPool.splice(indexInTertiary, 1); } }); const selectedForOutput = []; let duplicateInsightGain = 0; const selectWeightedRandomFromPool = (pool) => { if (pool.length === 0) return null; let totalWeight = 0; const weightedPool = pool.map(card => { let weight = 1.0; const rarityBonus = 1 + (currentAttunement / MAX_ATTUNEMENT); if (card.rarity === 'uncommon') weight *= (1.5 * rarityBonus); if (card.rarity === 'rare') weight *= (2.0 * rarityBonus); totalWeight += weight; return { card, weight }; }); let randomPick = Math.random() * totalWeight; let chosenCard = null; for (let i = 0; i < weightedPool.length; i++) { const item = weightedPool[i]; if (randomPick < item.weight) { chosenCard = item.card; const originalIndex = pool.findIndex(c => c.id === chosenCard.id); if (originalIndex > -1) pool.splice(originalIndex, 1); break; } randomPick -= item.weight; } if (!chosenCard && pool.length > 0) { console.warn("Weighted fallback."); const fallbackIndex = Math.floor(Math.random() * pool.length); chosenCard = pool[fallbackIndex]; pool.splice(fallbackIndex, 1); } return chosenCard; }; let attempts = 0; const maxAttempts = 10; while (selectedForOutput.length < 3 && attempts < maxAttempts && (priorityPool.length > 0 || secondaryPool.length > 0 || tertiaryPool.length > 0)) { attempts++; let potentialCard = selectWeightedRandomFromPool(priorityPool) || selectWeightedRandomFromPool(secondaryPool) || selectWeightedRandomFromPool(tertiaryPool); if (potentialCard) { if (discoveredConcepts.has(potentialCard.id)) { console.log(`Duplicate research hit: ${potentialCard.name}. Granting Insight.`); gainInsight(1.0, `Duplicate Research (${potentialCard.name})`); duplicateInsightGain += 1.0; } else { selectedForOutput.push(potentialCard); [priorityPool, secondaryPool, tertiaryPool].forEach(p => { const index = p.findIndex(c => c.id === potentialCard.id); if (index > -1) p.splice(index, 1); }); } } else { break; } } let resultMessage = ""; if (selectedForOutput.length > 0) { resultMessage = `Discovered ${selectedForOutput.length} new concept(s)! `; if (researchModalContent) researchModalContent.innerHTML = ''; selectedForOutput.forEach(concept => { const cardElement = renderCard(concept, 'research-result'); if (researchModalContent) researchModalContent.appendChild(cardElement); }); gainAttunementForAction('researchSuccess', elementKeyToResearch, 0.8); } else { resultMessage = "No new concepts discovered this time. "; if (researchModalContent) researchModalContent.innerHTML = '<p><i>Familiar thoughts...</i></p>'; gainAttunementForAction('researchFail', elementKeyToResearch, 0.2); } if (duplicateInsightGain > 0) { resultMessage += ` Gained ${duplicateInsightGain.toFixed(0)} Insight from echoes.`; } if (researchModalStatus) researchModalStatus.textContent = resultMessage.trim(); if (researchStatus) researchStatus.textContent = `Research complete. ${resultMessage.trim()}`; if (researchModal) researchModal.classList.remove('hidden'); if (popupOverlay) popupOverlay.classList.remove('hidden'); }

// --- Grimoire Functions ---
function displayGrimoire(filterType = "All", filterElement = "All", sortBy = "discovered", filterRarity = "All") { if (!grimoireContentDiv) return; grimoireContentDiv.innerHTML = ''; if (discoveredConcepts.size === 0) { grimoireContentDiv.innerHTML = '<p>Grimoire is empty...</p>'; return; } let discoveredArray = Array.from(discoveredConcepts.values()); const conceptsToDisplay = discoveredArray.filter(data => { if (!data || !data.concept) return false; const concept = data.concept; const typeMatch = (filterType === "All") || (concept.cardType === filterType); const elementMatch = (filterElement === "All") || (concept.primaryElement === elementNameToKey[filterElement]); const rarityMatch = (filterRarity === "All") || (concept.rarity === filterRarity); return typeMatch && elementMatch && rarityMatch; }); if (sortBy === 'name') conceptsToDisplay.sort((a, b) => a.concept.name.localeCompare(b.concept.name)); else if (sortBy === 'type') conceptsToDisplay.sort((a, b) => a.concept.cardType.localeCompare(b.concept.cardType) || a.concept.name.localeCompare(b.concept.name)); else if (sortBy === 'rarity') { const order = { 'common': 1, 'uncommon': 2, 'rare': 3 }; conceptsToDisplay.sort((a, b) => (order[a.concept.rarity] || 0) - (order[b.concept.rarity] || 0) || a.concept.name.localeCompare(b.concept.name)); } else conceptsToDisplay.sort((a,b) => a.discoveredTime - b.discoveredTime); if (conceptsToDisplay.length === 0) { grimoireContentDiv.innerHTML = `<p>No discovered concepts match filters.</p>`; } else { conceptsToDisplay.forEach(data => { const cardElement = renderCard(data.concept, 'grimoire'); grimoireContentDiv.appendChild(cardElement); }); } }
function populateGrimoireFilters() { if (grimoireTypeFilter) { grimoireTypeFilter.innerHTML = '<option value="All">All Types</option>'; cardTypeKeys.forEach(type => { const option = document.createElement('option'); option.value = type; option.textContent = type; grimoireTypeFilter.appendChild(option); }); } if (grimoireElementFilter) { grimoireElementFilter.innerHTML = '<option value="All">All Elements</option>'; elementNames.forEach(fullName => { const name = elementDetails[fullName]?.name || fullName; const option = document.createElement('option'); option.value = name; option.textContent = name; grimoireElementFilter.appendChild(option); }); } }
function updateGrimoireCounter() { if (grimoireCountSpan) grimoireCountSpan.textContent = discoveredConcepts.size; }

// --- Card Rendering Function ---
function renderCard(concept, context = 'grimoire') { if (!concept || !concept.id) { console.warn("renderCard invalid concept"); return document.createElement('div'); } if (typeof elementKeyToFullName === 'undefined') { console.error("renderCard: map missing!"); } const cardDiv = document.createElement('div'); cardDiv.classList.add('concept-card'); cardDiv.classList.add(`rarity-${concept.rarity || 'common'}`); cardDiv.dataset.conceptId = concept.id; cardDiv.title = `View ${concept.name}`; const discoveredData = discoveredConcepts.get(concept.id); const isDiscovered = !!discoveredData; const isFocused = focusedConcepts.has(concept.id); const artUnlocked = discoveredData?.artUnlocked || false; const grimoireStampHTML = isDiscovered ? '<span class="grimoire-stamp" title="In Grimoire"><i class="fas fa-book-open"></i></span>' : ''; const focusStampHTML = isFocused ? '<span class="focus-indicator" title="Focused Concept">★</span>' : ''; const cardTypeIcon = getCardTypeIcon(concept.cardType); let affinitiesHTML = ''; if (concept.elementScores && typeof elementKeyToFullName !== 'undefined') { Object.entries(concept.elementScores).forEach(([key, score]) => { const level = getAffinityLevel(score); if (level && elementKeyToFullName[key]) { const fullName = elementKeyToFullName[key]; const color = getElementColor(fullName); const levelClass = level === "High" ? "affinity-high" : ""; affinitiesHTML += `<span class="affinity ${levelClass}" style="border-color: ${color}; color: ${color}; background-color: ${hexToRgba(color, 0.1)};" title="${elementDetails[fullName]?.name || fullName} Affinity: ${level}"><i class="${getElementIcon(fullName)}"></i> ${level.substring(0,1)}</span> `; } }); } const currentVisualHandle = artUnlocked ? (concept.visualHandleUnlocked || concept.visualHandle) : concept.visualHandle; const visualContent = artUnlocked && concept.visualHandleUnlocked ? `<img src="placeholder_art/${concept.visualHandleUnlocked}.png" alt="${concept.name} Art" class="card-art-image">` : `<i class="fas fa-${artUnlocked ? 'star' : 'question'} card-visual-placeholder ${artUnlocked ? 'card-art-unlocked' : ''}" title="${currentVisualHandle}"></i>`; cardDiv.innerHTML = ` <div class="card-header"> <i class="${cardTypeIcon} card-type-icon" title="${concept.cardType}"></i> <span class="card-name">${concept.name}</span> <span class="card-stamps">${focusStampHTML}${grimoireStampHTML}</span> </div> <div class="card-visual"> ${visualContent} </div> <div class="card-footer"> <div class="card-affinities">${affinitiesHTML || '<small style="color:#888; font-style: italic;">Basic Affinity</small>'}</div> <p class="card-brief-desc">${concept.briefDescription || '...'}</p> </div>`; if (context !== 'no-click') { cardDiv.addEventListener('click', () => showConceptDetailPopup(concept.id)); } if (context === 'research-result') { cardDiv.title = `Click to view details for ${concept.name}`; } return cardDiv; }

// --- Concept Detail Pop-up Logic ---
function showConceptDetailPopup(conceptId) { const conceptData = concepts.find(c => c.id === conceptId); const discoveredData = discoveredConcepts.get(conceptId); if (!conceptData) { console.error(`Concept ${conceptId} not found!`); return; } currentlyDisplayedConceptId = conceptId; if (popupConceptName) popupConceptName.textContent = conceptData.name; if (popupConceptType) popupConceptType.textContent = conceptData.cardType; if (popupCardTypeIcon) popupCardTypeIcon.className = `${getCardTypeIcon(conceptData.cardType)} card-type-icon`; if (popupDetailedDescription) popupDetailedDescription.textContent = conceptData.detailedDescription || "No description."; const artUnlocked = discoveredData?.artUnlocked || false; const currentVisualHandle = artUnlocked ? (conceptData.visualHandleUnlocked || conceptData.visualHandle) : conceptData.visualHandle; if (popupVisualContainer) { popupVisualContainer.innerHTML = ''; if (artUnlocked && conceptData.visualHandleUnlocked) { const img = document.createElement('img'); img.src = `placeholder_art/${conceptData.visualHandleUnlocked}.png`; img.alt = `${conceptData.name} Art`; img.classList.add('card-art-image'); popupVisualContainer.appendChild(img); } else { const icon = document.createElement('i'); icon.className = `fas fa-${artUnlocked ? 'star card-art-unlocked' : 'question card-visual-placeholder'}`; icon.title = currentVisualHandle || "Visual"; popupVisualContainer.appendChild(icon); } } else { console.error("popupVisualContainer element not found!"); } const distance = euclideanDistance(userScores, conceptData.elementScores); displayPopupResonance(distance); displayPopupRecipeComparison(conceptData); displayPopupRelatedConcepts(conceptData); displayEvolutionSection(conceptData, discoveredData); updateGrimoireButtonStatus(conceptId); updateFocusButtonStatus(conceptId); if (conceptDetailPopup) conceptDetailPopup.classList.remove('hidden'); if (popupOverlay) popupOverlay.classList.remove('hidden'); }
function displayPopupResonance(distance) { if (!popupResonanceSummary) return; let resonanceLabel = "Low"; let resonanceClass = "resonance-low"; if (distance === Infinity || isNaN(distance)) { resonanceLabel = "N/A"; resonanceClass = ""; } else if (distance <= DISSONANCE_THRESHOLD && distance < 2.5) { resonanceLabel = "Very High"; resonanceClass = "resonance-high"; } else if (distance <= DISSONANCE_THRESHOLD && distance < 4.0) { resonanceLabel = "High"; resonanceClass = "resonance-high"; } else if (distance <= DISSONANCE_THRESHOLD && distance < 6.0) { resonanceLabel = "Moderate"; resonanceClass = "resonance-medium"; } else if (distance > DISSONANCE_THRESHOLD) { resonanceLabel = "Dissonant"; resonanceClass = "resonance-low"; } popupResonanceSummary.innerHTML = `Resonance with You: <span class="resonance-indicator ${resonanceClass}">${resonanceLabel}</span> (Dist: ${distance.toFixed(1)})`; }
function displayPopupRecipeComparison(conceptData) { if (!popupConceptProfile || !popupUserComparisonProfile || !popupComparisonHighlights) return; if (typeof elementKeyToFullName === 'undefined') { console.error("RecipeComparison: map missing!"); return; } popupConceptProfile.innerHTML = ''; popupUserComparisonProfile.innerHTML = ''; popupComparisonHighlights.innerHTML = ''; let highlightsHTML = '<p><strong>Key Alignments & Differences:</strong></p>'; let hasHighlights = false; const conceptScores = conceptData.elementScores || {}; const userCompScores = userScores || {}; elementNames.forEach(elName => { const key = elementNameToKey[elName]; const fullName = elementKeyToFullName[key]; if (!fullName) return; const conceptScore = conceptScores[key]; const userScore = userCompScores[key]; const conceptLabel = getScoreLabel(conceptScore); const userLabel = getScoreLabel(userScore); const conceptBarWidth = conceptScore ? (conceptScore / 10) * 100 : 0; const userBarWidth = userScore ? (userScore / 10) * 100 : 0; const color = getElementColor(fullName); popupConceptProfile.innerHTML += `<div><strong>${elementDetails[fullName]?.name.substring(0, 11) || elName}:</strong> <span>${conceptScore?.toFixed(1) ?? '?'}</span> <div class="score-bar-container"><div style="width: ${conceptBarWidth}%; background-color: ${color};"></div></div></div>`; popupUserComparisonProfile.innerHTML += `<div><strong>${elementDetails[fullName]?.name.substring(0, 11) || elName}:</strong> <span>${userScore?.toFixed(1) ?? '?'}</span> <div class="score-bar-container"><div style="width: ${userBarWidth}%; background-color: ${color};"></div></div></div>`; const diff = Math.abs(conceptScore - userScore); if (conceptScore >= 7 && userScore >= 7) { highlightsHTML += `<p>• <strong class="match">Strong Alignment</strong> in ${elementDetails[fullName]?.name || elName} (${userLabel})</p>`; hasHighlights = true; } else if (conceptScore <= 3 && userScore <= 3) { highlightsHTML += `<p>• <strong class="match">Shared Low Emphasis</strong> in ${elementDetails[fullName]?.name || elName} (${userLabel})</p>`; hasHighlights = true; } else if (diff >= 4) { const direction = conceptScore > userScore ? "higher" : "lower"; highlightsHTML += `<p>• <strong class="mismatch">Notable Difference</strong> in ${elementDetails[fullName]?.name || elName} (Concept is ${conceptLabel}, You are ${userLabel})</p>`; hasHighlights = true; } }); if (!hasHighlights) highlightsHTML += '<p><em>No strong alignments or major differences.</em></p>'; popupComparisonHighlights.innerHTML = highlightsHTML; }
function displayPopupRelatedConcepts(conceptData) { if (!popupRelatedConceptsList) return; popupRelatedConceptsList.innerHTML = ''; if (conceptData.relatedIds && conceptData.relatedIds.length > 0) { conceptData.relatedIds.forEach(relatedId => { const relatedConcept = concepts.find(c => c.id === relatedId); if (relatedConcept) { const li = document.createElement('li'); li.textContent = relatedConcept.name; li.dataset.conceptId = relatedId; li.addEventListener('click', handleRelatedConceptClick); popupRelatedConceptsList.appendChild(li); } }); } else { popupRelatedConceptsList.innerHTML = '<li>None specified</li>'; } }
function handleRelatedConceptClick(event) { const conceptId = event.target.dataset.conceptId; if (!conceptId) return; const numericId = parseInt(conceptId); if (!isNaN(numericId)) { showConceptDetailPopup(numericId); } }
function displayEvolutionSection(conceptData, discoveredData) { if (!popupEvolutionSection || !evolveArtButton || !evolveEligibility || !evolveCostSpan) return; if (typeof elementKeyToFullName === 'undefined') { console.error("EvolutionSection: map missing!"); return; } const isDiscovered = !!discoveredData; const canUnlock = conceptData.canUnlockArt; const alreadyUnlocked = discoveredData?.artUnlocked || false; const isFocused = focusedConcepts.has(conceptData.id); const requiredElement = conceptData.primaryElement; const fullName = elementKeyToFullName[requiredElement]; if (!fullName) { console.warn(`Evolution: Invalid primary element key ${requiredElement} for concept ${conceptData.id}`); popupEvolutionSection.classList.add('hidden'); return; } const cost = ART_EVOLVE_COST; const hasEnoughInsight = userInsight >= cost; const hasReflected = seenPrompts.size > 0; evolveCostSpan.textContent = `${cost} Insight`; if (isDiscovered && canUnlock && !alreadyUnlocked) { popupEvolutionSection.classList.remove('hidden'); let eligibilityText = ''; let canEvolve = true; if (!isFocused) { eligibilityText += '<li>Mark as Focus Concept</li>'; canEvolve = false; } else { eligibilityText += '<li><i class="fas fa-check"></i> Focused Concept</li>'; } if (!hasReflected) { eligibilityText += '<li>Engage in Reflection</li>'; canEvolve = false; } else { eligibilityText += '<li><i class="fas fa-check"></i> Reflection Engaged</li>'; } if (!hasEnoughInsight) { eligibilityText += `<li>Need ${cost} Insight (Have ${userInsight.toFixed(1)})</li>`; canEvolve = false;} else { eligibilityText += `<li><i class="fas fa-check"></i> Enough Insight</li>`; } evolveEligibility.innerHTML = `<ul>${eligibilityText}</ul>`; evolveEligibility.classList.remove('hidden'); evolveArtButton.disabled = !canEvolve; evolveArtButton.onclick = canEvolve ? () => attemptArtEvolution(conceptData.id, cost) : null; } else { popupEvolutionSection.classList.add('hidden'); evolveArtButton.disabled = true; evolveEligibility.classList.add('hidden'); evolveArtButton.onclick = null; } }
function attemptArtEvolution(conceptId, cost) { console.log(`Attempting art evolution for ${conceptId} costing ${cost} Insight.`); const discoveredData = discoveredConcepts.get(conceptId); if (!discoveredData || !discoveredData.concept || discoveredData.artUnlocked) { console.error("Cannot evolve: Not discovered/unlocked."); return; } const concept = discoveredData.concept; if (!concept.canUnlockArt) { console.error("Cannot evolve: Art not unlockable."); return; } const isFocused = focusedConcepts.has(conceptId); const hasReflected = seenPrompts.size > 0; if (isFocused && hasReflected && userInsight >= cost) { userInsight -= cost; updateInsightDisplays(); discoveredData.artUnlocked = true; discoveredConcepts.set(conceptId, discoveredData); console.log(`Art unlocked for ${concept.name}!`); showTemporaryMessage(`Enhanced Art Unlocked for ${concept.name}!`); if (currentlyDisplayedConceptId === conceptId) { displayEvolutionSection(concept, discoveredData); if (popupVisualContainer) { popupVisualContainer.innerHTML = ''; if (discoveredData.artUnlocked && concept.visualHandleUnlocked) { const img = document.createElement('img'); img.src = `placeholder_art/${concept.visualHandleUnlocked}.png`; img.alt = `${concept.name} Art`; img.classList.add('card-art-image'); popupVisualContainer.appendChild(img); } else { const icon = document.createElement('i'); icon.className = `fas fa-star card-visual-placeholder card-art-unlocked`; icon.title = concept.visualHandleUnlocked || concept.visualHandle || "Visual"; popupVisualContainer.appendChild(icon); } } } if (grimoireScreen.classList.contains('current')) { displayGrimoire(); } gainAttunementForAction('artEvolve', concept.primaryElement, 1.5); updateMilestoneProgress('evolveArt', 1); checkAndUpdateRituals('evolveArt'); } else { console.warn("Evolution conditions not met."); alert("Cannot unlock art yet. Check requirements: Focus Status, Reflection, Insight."); } }

// --- Grimoire/Focus Button & State Logic ---
function addToGrimoire() { if (currentlyDisplayedConceptId === null) return; const concept = concepts.find(c => c.id === currentlyDisplayedConceptId); if (!concept) { console.error("Concept not found"); return; } if (discoveredConcepts.has(concept.id)) { showTemporaryMessage(`${concept.name} is already in Grimoire.`); return; } const distance = euclideanDistance(userScores, concept.elementScores); if (distance > DISSONANCE_THRESHOLD) { console.log(`Dissonance detected. Triggering reflection for ${concept.name}`); displayReflectionPrompt('Dissonance', concept.id); } else { addConceptToGrimoireInternal(concept.id); } }
function addConceptToGrimoireInternal(conceptId) { const concept = concepts.find(c => c.id === conceptId); if (!concept) { console.error(`Internal Add: Concept ${conceptId} not found`); return; } if (discoveredConcepts.has(conceptId)) { console.warn(`Internal Add: Concept ${conceptId} already discovered.`); return; } console.log(`Adding ${concept.name} to Grimoire (Internal).`); discoveredConcepts.set(conceptId, { concept: concept, discoveredTime: Date.now(), artUnlocked: false }); gainInsight(2.0, `Discovered ${concept.name}`); gainAttunementForAction('addToGrimoire', concept.primaryElement, 0.6); updateGrimoireCounter(); if (currentlyDisplayedConceptId === conceptId) { updateGrimoireButtonStatus(concept.id); updateFocusButtonStatus(concept.id); } checkTriggerReflectionPrompt('add'); updateMilestoneProgress('addToGrimoire', 1); updateMilestoneProgress('discoveredConcepts.size', discoveredConcepts.size); checkAndUpdateRituals('addToGrimoire'); if (grimoireScreen.classList.contains('current')) { displayGrimoire(); } showTemporaryMessage(`${concept.name} added to Grimoire!`); }
function toggleFocusConcept() { if (currentlyDisplayedConceptId === null) return; const discoveredData = discoveredConcepts.get(currentlyDisplayedConceptId); if (!discoveredData || !discoveredData.concept) { console.error("Concept not discovered."); return; } const concept = discoveredData.concept; if (focusedConcepts.has(concept.id)) { focusedConcepts.delete(concept.id); console.log(`Removed ${concept.name} from Focus.`); showTemporaryMessage(`${concept.name} removed from Focus.`); checkAndUpdateRituals('removeFocus'); } else { if (focusedConcepts.size >= focusSlotsTotal) { alert(`Focus slots full (${focusedConcepts.size}/${focusSlotsTotal}). Remove another first.`); console.warn("Focus limit reached."); return; } focusedConcepts.add(concept.id); console.log(`Marked ${concept.name} as Focus.`); showTemporaryMessage(`${concept.name} marked as Focus!`); gainInsight(1.0, `Focused on ${concept.name}`); gainAttunementForAction('markFocus', concept.primaryElement, 1.0); updateMilestoneProgress('markFocus', 1); updateMilestoneProgress('focusedConcepts.size', focusedConcepts.size); checkAndUpdateRituals('markFocus'); } updateFocusButtonStatus(concept.id); displayFocusedConceptsPersona(); synthesizeAndDisplayThemesPersona(); if (grimoireScreen.classList.contains('current')) { displayGrimoire(); } }
function updateGrimoireButtonStatus(conceptId) { if (!addToGrimoireButton) return; const isDiscovered = discoveredConcepts.has(conceptId); addToGrimoireButton.disabled = isDiscovered; addToGrimoireButton.textContent = isDiscovered ? "In Grimoire" : "Add to Grimoire"; addToGrimoireButton.classList.toggle('added', isDiscovered); }
function updateFocusButtonStatus(conceptId) { if (!markAsFocusButton) return; const isDiscovered = discoveredConcepts.has(conceptId); const isFocused = focusedConcepts.has(conceptId); markAsFocusButton.classList.toggle('hidden', !isDiscovered); if (isDiscovered) { markAsFocusButton.textContent = isFocused ? "Remove Focus" : "Mark as Focus"; markAsFocusButton.classList.toggle('marked', isFocused); } }

// --- Reflection Prompts ---
function checkTriggerReflectionPrompt(triggerAction = 'other') { if (promptCooldownActive) return; if (triggerAction === 'add') cardsAddedSinceLastPrompt++; if (triggerAction === 'completeQuestionnaire') cardsAddedSinceLastPrompt = 99; const triggerThreshold = 3; if (cardsAddedSinceLastPrompt >= triggerThreshold) { displayReflectionPrompt('Standard'); cardsAddedSinceLastPrompt = 0; promptCooldownActive = true; setTimeout(() => { promptCooldownActive = false; console.log("Reflection cooldown ended."); }, 1000 * 60 * 5); } }
function displayReflectionPrompt(context = 'Standard', targetConceptIdForDissonance = null) { currentReflectionContext = context; reflectionTargetConceptId = targetConceptIdForDissonance; let promptPool = []; let titleElement = "Element"; const nudgeElements = [scoreNudgeCheckbox, scoreNudgeLabel]; if (context === 'Dissonance') { promptPool = reflectionPrompts["Dissonance"] || []; const targetConcept = concepts.find(c => c.id === targetConceptIdForDissonance); titleElement = targetConcept ? `${targetConcept.name} (Dissonant)` : "a Challenging Concept"; console.log(`Displaying Dissonance reflection for ${targetConceptIdForDissonance}`); nudgeElements.forEach(el => el?.classList.remove('hidden')); } else { let possibleElements = elementNames.filter(elName => reflectionPrompts[elName] && reflectionPrompts[elName].length > 0); if (possibleElements.length === 0) { console.warn("No standard prompts."); return; } const targetElementName = possibleElements[Math.floor(Math.random() * possibleElements.length)]; promptPool = reflectionPrompts[targetElementName] || []; titleElement = elementDetails[targetElementName]?.name || targetElementName; currentReflectionElement = targetElementName; console.log(`Displaying Standard reflection for ${targetElementName}`); nudgeElements.forEach(el => el?.classList.add('hidden')); } if (promptPool.length === 0) { console.error(`No prompts for context: ${context}`); return; } const availablePrompts = promptPool.filter(p => !seenPrompts.has(p.id)); let selectedPrompt = availablePrompts.length > 0 ? availablePrompts[Math.floor(Math.random() * availablePrompts.length)] : promptPool[Math.floor(Math.random() * promptPool.length)]; if (!selectedPrompt) { console.error("Could not select prompt."); return; } currentPromptId = selectedPrompt.id; if (reflectionElement) reflectionElement.textContent = titleElement; if (reflectionPromptText) reflectionPromptText.textContent = selectedPrompt.text; if (reflectionCheckbox) reflectionCheckbox.checked = false; if (scoreNudgeCheckbox) scoreNudgeCheckbox.checked = false; if (confirmReflectionButton) confirmReflectionButton.disabled = true; const rewardAmount = 5.0; if (reflectionRewardAmount) reflectionRewardAmount.textContent = `${rewardAmount} Insight`; if (reflectionModal) reflectionModal.classList.remove('hidden'); if (popupOverlay) popupOverlay.classList.remove('hidden'); }
function handleConfirmReflection() { if (!currentPromptId || !reflectionCheckbox || !reflectionCheckbox.checked) return; console.log(`Reflection confirmed: ${currentReflectionContext}, prompt: ${currentPromptId}`); seenPrompts.add(currentPromptId); const insightReward = 5.0; let attunementKey = null; let attunementAmount = 1.0; let milestoneAction = 'completeReflection'; if (currentReflectionContext === 'Dissonance' && scoreNudgeCheckbox && scoreNudgeCheckbox.checked) { console.log("Score nudge requested."); const concept = concepts.find(c => c.id === reflectionTargetConceptId); if (concept?.elementScores) { let nudged = false; for (const key in userScores) { if (userScores.hasOwnProperty(key) && concept.elementScores.hasOwnProperty(key)) { const userScore = userScores[key]; const conceptScore = concept.elementScores[key]; const diff = conceptScore - userScore; if (Math.abs(diff) > 2.0) { const nudge = Math.sign(diff) * SCORE_NUDGE_AMOUNT; userScores[key] = Math.max(0, Math.min(10, userScore + nudge)); console.log(` -> Nudged ${key} score by ${nudge.toFixed(2)}. New: ${userScores[key].toFixed(2)}`); nudged = true; } } } if (nudged) { console.log("Updated User Scores:", userScores); displayPersonaScreen(); showTemporaryMessage("Core understanding shifted."); gainAttunementForAction('scoreNudge', null, 0.5); } } else { console.warn("Could not find concept for nudge."); } } if (currentReflectionContext === 'Dissonance' && reflectionTargetConceptId !== null) { addConceptToGrimoireInternal(reflectionTargetConceptId); milestoneAction = 'completeReflectionDissonance'; attunementAmount = 0.5; } gainInsight(insightReward, `Reflection (${currentReflectionContext})`); if (currentReflectionContext === 'Standard' && currentReflectionElement) { attunementKey = elementNameToKey[currentReflectionElement]; } else { attunementKey = null; } if (attunementKey) { gainAttunementForAction('completeReflection', attunementKey, attunementAmount); } else { gainAttunementForAction('completeReflectionGeneric', 'All', 0.2); } updateMilestoneProgress(milestoneAction, 1); checkAndUpdateRituals('completeReflection'); hidePopups(); showTemporaryMessage("Reflection complete! Insight gained."); currentReflectionContext = null; reflectionTargetConceptId = null; }

// --- Rituals & Milestones ---
function displayDailyRituals() { if (!dailyRitualsDisplay) return; dailyRitualsDisplay.innerHTML = ''; if (!dailyRituals || dailyRituals.length === 0) { dailyRitualsDisplay.innerHTML = '<li>No rituals.</li>'; return; } dailyRituals.forEach(ritual => { const completedData = completedRituals.daily[ritual.id] || {completed: false, progress: 0}; const isCompleted = completedData.completed; const li = document.createElement('li'); li.classList.toggle('completed', isCompleted); let rewardText = ''; if (ritual.reward) { if (ritual.reward.type === 'insight') rewardText = `(+${ritual.reward.amount} Insight)`; else if (ritual.reward.type === 'attunement') rewardText = `(+${ritual.reward.amount} Attunement)`; else if (ritual.reward.type === 'token') rewardText = `(+1 ${ritual.reward.tokenType || 'Research'} Token)`; } li.innerHTML = `${ritual.description} <span class="ritual-reward">${rewardText}</span>`; dailyRitualsDisplay.appendChild(li); }); }
function checkAndUpdateRituals(action, details = {}) { console.log("Checking rituals for action:", action, details); let ritualUpdated = false; dailyRituals.forEach(ritual => { let completedData = completedRituals.daily[ritual.id] || {completed: false, progress: 0}; if (!completedData.completed && ritual.track.action === action) { completedData.progress++; if (completedData.progress >= ritual.track.count) { console.log(`Ritual Completed: ${ritual.description}`); completedData.completed = true; ritualUpdated = true; if (ritual.reward) { if (ritual.reward.type === 'insight') { gainInsight(ritual.reward.amount || 0, `Ritual: ${ritual.description}`); } else if (ritual.reward.type === 'attunement') { gainAttunementForAction('ritual', ritual.reward.element || 'All', ritual.reward.amount || 0); } else if (ritual.reward.type === 'token') { console.log(`TODO: Grant ${ritual.reward.tokenType || 'Research'} token`); } } } completedRituals.daily[ritual.id] = completedData; } }); if (ritualUpdated) displayDailyRituals(); }
function displayMilestones() { if (!milestonesDisplay) return; milestonesDisplay.innerHTML = ''; if (achievedMilestones.size === 0) { milestonesDisplay.innerHTML = '<li>No milestones achieved yet.</li>'; return; } achievedMilestones.forEach(milestoneId => { const milestone = milestones.find(m => m.id === milestoneId); if (milestone) { const li = document.createElement('li'); li.textContent = `✓ ${milestone.description}`; milestonesDisplay.appendChild(li); } }); }
function updateMilestoneProgress(trackType, currentValue) { milestones.forEach(m => { if (!achievedMilestones.has(m.id)) { let achieved = false; if (m.track.action === trackType && currentValue >= (m.track.count || 1)) achieved = true; else if (m.track.state === trackType) { if (m.track.condition === "any") { if (typeof currentValue === 'object') { for (const key in currentValue) { if (elementAttunement.hasOwnProperty(key) && currentValue[key] >= m.track.threshold) { achieved = true; break; } } } } else if (m.track.condition === "all") { if (typeof currentValue === 'object') { let allMet = true; for (const key in elementAttunement) { if (!(currentValue.hasOwnProperty(key) && currentValue[key] >= m.track.threshold)) { allMet = false; break; } } if (allMet) achieved = true; } } else { if (currentValue >= m.track.threshold) achieved = true; } } if (achieved) { console.log("Milestone Achieved!", m.description); achievedMilestones.add(m.id); displayMilestones(); showMilestoneAlert(m.description); if (m.reward) { if (m.reward.type === 'insight') { gainInsight(m.reward.amount || 0, `Milestone: ${m.description}`); } else if (m.reward.type === 'attunement') { gainAttunementForAction('milestone', m.reward.element || 'All', m.reward.amount || 0); } else if (m.reward.type === 'increaseFocusSlots') { const increaseAmount = m.reward.amount || 1; if (focusSlotsTotal < MAX_FOCUS_SLOTS) { focusSlotsTotal = Math.min(MAX_FOCUS_SLOTS, focusSlotsTotal + increaseAmount); console.log(`Focus Slots increased by ${increaseAmount}. New: ${focusSlotsTotal}`); updateFocusSlotsDisplay(); } } else if (m.reward.type === 'discoverCard') { const cardIdToDiscover = m.reward.cardId; if (cardIdToDiscover && !discoveredConcepts.has(cardIdToDiscover)) { const conceptToDiscover = concepts.find(c => c.id === cardIdToDiscover); if (conceptToDiscover) { console.log(`Milestone Reward: Discovering ${conceptToDiscover.name}`); addConceptToGrimoireInternal(cardIdToDiscover); showTemporaryMessage(`Milestone Reward: Discovered ${conceptToDiscover.name}!`); } else { console.warn(`Milestone discoverCard reward: Card ID ${cardIdToDiscover} not found.`); } } } } } } }); if (trackType === 'focusedConcepts.size' || trackType === 'discoverCard' || trackType === 'increaseFocusSlots') { updateMilestoneProgress('focusSlotsTotal', focusSlotsTotal); } }
function showMilestoneAlert(text) { if (!milestoneAlert || !milestoneAlertText) return; milestoneAlertText.textContent = `Milestone: ${text}`; milestoneAlert.classList.remove('hidden'); setTimeout(hideMilestoneAlert, 5000); }
function hideMilestoneAlert() { if (milestoneAlert) milestoneAlert.classList.add('hidden'); }
function showTemporaryMessage(message, duration = 3000) { console.info(`Message: ${message}`); /* TODO: implement toast */ }

// --- Reset App ---
function resetApp() { if (confirm("Reset all progress? Cannot be undone.")) { console.log("Resetting application..."); initializeQuestionnaire(); showScreen('welcomeScreen'); } }

// --- Daily Login Check ---
function checkForDailyLogin() { const today = new Date().toDateString(); if (lastLoginDate !== today) { console.log("First login of the day detected."); completedRituals.daily = {}; lastLoginDate = today; freeResearchAvailableToday = true; console.log("Free daily research granted."); if(freeResearchButton) freeResearchButton.classList.remove('hidden'); displayDailyRituals(); displayResearchButtons(); gainInsight(5.0, "Daily Login"); showTemporaryMessage("Daily rituals reset. Free research available!"); } else { displayResearchButtons(); } }

// --- Event Listeners (MUST BE AT THE END) ---
document.addEventListener('DOMContentLoaded', () => {
    console.log("DOM Fully Loaded. Initializing Card Concept Expanded..."); // Log 1
    navButtons.forEach(button => { button.addEventListener('click', () => { const targetScreenId = button.dataset.target; if (!document.getElementById(targetScreenId)) { console.error(`Target screen #${targetScreenId} not found!`); return; } if (targetScreenId === 'personaScreen') { displayPersonaScreen(); } if (targetScreenId === 'studyScreen') { displayStudyScreenContent(); } if (targetScreenId === 'grimoireScreen') { displayGrimoire(grimoireTypeFilter.value, grimoireElementFilter.value, grimoireSortOrder.value, grimoireRarityFilter.value); } showScreen(targetScreenId); }); });
    if (startButton) { console.log("Attempting to add listener to Start Button:", startButton); startButton.addEventListener('click', () => { console.log("Start Button Clicked!"); initializeQuestionnaire(); }); } else { console.error("Start button not found!"); } // Log 2 & 3 (on click)
    if (nextElementButton) nextElementButton.addEventListener('click', nextElement); else console.error("Next button not found!");
    if (prevElementButton) prevElementButton.addEventListener('click', prevElement); else console.error("Prev button not found!");
    if (restartButtonPersona) restartButtonPersona.addEventListener('click', resetApp); else console.error("Restart button (Persona) not found!");
    if (closePopupButton) closePopupButton.addEventListener('click', hidePopups); else console.error("Close Popup button not found!");
    if (popupOverlay) popupOverlay.addEventListener('click', hidePopups); else console.error("Popup Overlay not found!");
    if (closeResearchModalButton) closeResearchModalButton.addEventListener('click', hidePopups); else console.error("Close Research Modal button not found!");
    if (closeReflectionModalButton) closeReflectionModalButton.addEventListener('click', hidePopups); else console.error("Close Reflection Modal button not found!");
    if (closeMilestoneAlertButton) closeMilestoneAlertButton.addEventListener('click', hideMilestoneAlert); else console.error("Close Milestone Alert button not found!");
    if (addToGrimoireButton) addToGrimoireButton.addEventListener('click', addToGrimoire); else console.error("Add to Grimoire button not found!");
    if (markAsFocusButton) markAsFocusButton.addEventListener('click', toggleFocusConcept); else console.error("Mark as Focus button not found!");
    const grimoireRefresh = () => { if (!grimoireScreen.classList.contains('hidden')) { displayGrimoire(grimoireTypeFilter.value, grimoireElementFilter.value, grimoireSortOrder.value, grimoireRarityFilter.value); } };
    if (grimoireTypeFilter) grimoireTypeFilter.addEventListener('change', grimoireRefresh); else console.error("Grimoire Type filter not found!");
    if (grimoireElementFilter) grimoireElementFilter.addEventListener('change', grimoireRefresh); else console.error("Grimoire Element filter not found!");
    if (grimoireRarityFilter) grimoireRarityFilter.addEventListener('change', grimoireRefresh); else console.error("Grimoire Rarity filter not found!");
    if (grimoireSortOrder) grimoireSortOrder.addEventListener('change', grimoireRefresh); else console.error("Grimoire Sort order not found!");
    if (reflectionCheckbox) reflectionCheckbox.addEventListener('change', () => { if(confirmReflectionButton) confirmReflectionButton.disabled = !reflectionCheckbox.checked; }); else console.error("Reflection checkbox not found!");
    if (confirmReflectionButton) confirmReflectionButton.addEventListener('click', handleConfirmReflection); else console.error("Confirm Reflection button not found!");
    showScreen('welcomeScreen'); console.log("Initial screen set to Welcome."); // Log 4
}); // End DOMContentLoaded
